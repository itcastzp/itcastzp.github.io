<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZP">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZP</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZP">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">并发编程模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-07-20 15:27:19 / 修改时间：15:27:43" itemprop="dateCreated datePublished" datetime="2020-07-20T15:27:19+08:00">2020-07-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h1><p>并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。这篇并发模型教程将会较深入地介绍目前（2015 年，本文撰写时间）比较流行的几种并发模型。</p>
<h2 id="并发模型与分布式系统之间的相似性"><a href="#并发模型与分布式系统之间的相似性" class="headerlink" title="并发模型与分布式系统之间的相似性"></a>并发模型与分布式系统之间的相似性</h2><p>本文所描述的并发模型类似于分布式系统中使用的很多体系结构。在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。线程和进程之间具有很多相似的特性。这也就是为什么很多并发模型通常类似于各种分布式系统架构。</p>
<p>当然，分布式系统在处理网络失效、远程主机或进程宕掉等方面也面临着额外的挑战。但是运行在巨型服务器上的并发系统也可能遇到类似的问题，比如一块 CPU 失效、一块网卡失效或一个磁盘损坏等情况。虽然出现失效的概率可能很低，但是在理论上仍然有可能发生。</p>
<p>由于并发模型类似于分布式系统架构，因此它们通常可以互相借鉴思想。例如，为工作者们（线程）分配作业的模型一般与分布式系统中的<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/software-architecture/load-balancing.html">负载均衡系统</a>比较相似。同样，它们在日志记录、失效转移、幂等性等错误处理技术上也具有相似性。</p>
<p>【注：幂等性，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同】</p>
<h2 id="并行工作者"><a href="#并行工作者" class="headerlink" title="并行工作者"></a>并行工作者</h2><p>第一种并发模型就是我所说的并行工作者模型。传入的作业会被分配到不同的工作者上。下图展示了并行工作者模型：</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/1.png" alt="img"></p>
<p>在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的 CPU 上。</p>
<p>如果在某个汽车厂里实现了并行工作者模型，每台车都会由一个工人来生产。工人们将拿到汽车的生产规格，并且从头到尾负责所有工作。</p>
<p>在 Java 应用系统中，并行工作者模型是最常见的并发模型（即使正在转变）。<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/index.html">java.util.concurrent</a>包中的许多并发实用工具都是设计用于这个模型的。你也可以在 Java 企业级（J2EE）应用服务器的设计中看到这个模型的踪迹。</p>
<h3 id="并行工作者模型的优点"><a href="#并行工作者模型的优点" class="headerlink" title="并行工作者模型的优点"></a>并行工作者模型的优点</h3><p>并行工作者模式的优点是，它很容易理解。你只需添加更多的工作者来提高系统的并行度。</p>
<p>例如，如果你正在做一个网络爬虫，可以试试使用不同数量的工作者抓取到一定数量的页面，然后看看多少数量的工作者消耗的时间最短（意味着性能最高）。由于网络爬虫是一个 IO 密集型工作，最终结果很有可能是你电脑中的每个 CPU 或核心分配了几个线程。每个 CPU 若只分配一个线程可能有点少，因为在等待数据下载的过程中 CPU 将会空闲大量时间。</p>
<h2 id="并行工作者模型的缺点"><a href="#并行工作者模型的缺点" class="headerlink" title="并行工作者模型的缺点"></a>并行工作者模型的缺点</h2><p>并行工作者模型虽然看起来简单，却隐藏着一些缺点。接下来的章节中我会分析一些最明显的弱点。</p>
<h3 id="共享状态可能会很复杂"><a href="#共享状态可能会很复杂" class="headerlink" title="共享状态可能会很复杂"></a>共享状态可能会很复杂</h3><p>在实际应用中，并行工作者模型可能比前面所描述的情况要复杂得多。共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的。下图展示了并行工作者模型是如何变得复杂的：</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/2.png" alt="img"></p>
<p>有些共享状态是在像作业队列这样的通信机制下。但也有一些共享状态是业务数据，数据缓存，数据库连接池等。</p>
<p>一旦共享状态潜入到并行工作者模型中，将会使情况变得复杂起来。线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。线程需要避免<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html">竟态</a>，<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/deadlock.html">死锁</a>以及很多其他共享状态的并发性问题。</p>
<p>此外，在等待访问共享数据结构时，线程之间的互相等待将会丢失部分并行性。许多并发数据结构是阻塞的，意味着在任何一个时间只有一个或者很少的线程能够访问。这样会导致在这些共享数据结构上出现竞争状态。在执行需要访问共享数据结构部分的代码时，高竞争基本上会导致执行时出现一定程度的串行化。</p>
<p>现在的<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html">非阻塞并发算法</a>也许可以降低竞争并提升性能，但是非阻塞算法的实现比较困难。</p>
<p>可持久化的数据结构是另一种选择。在修改的时候，可持久化的数据结构总是保护它的前一个版本不受影响。因此，如果多个线程指向同一个可持久化的数据结构，并且其中一个线程进行了修改，进行修改的线程会获得一个指向新结构的引用。所有其他线程保持对旧结构的引用，旧结构没有被修改并且因此保证一致性。Scala 编程包含几个持久化数据结构。</p>
<p>【注：这里的可持久化数据结构不是指持久化存储，而是一种数据结构，比如 Java 中的 String 类，以及 CopyOnWriteArrayList 类，具体可<a target="_blank" rel="noopener" href="http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html">参考</a>】</p>
<p>虽然可持久化的数据结构在解决共享数据结构的并发修改时显得很优雅，但是可持久化的数据结构的表现往往不尽人意。</p>
<p>比如说，一个可持久化的链表需要在头部插入一个新的节点，并且返回指向这个新加入的节点的一个引用（这个节点指向了链表的剩余部分）。所有其他现场仍然保留了这个链表之前的第一个节点，对于这些线程来说链表仍然是为改变的。它们无法看到新加入的元素。</p>
<p>这种可持久化的列表采用链表来实现。不幸的是链表在现代硬件上表现的不太好。链表中得每个元素都是一个独立的对象，这些对象可以遍布在整个计算机内存中。现代 CPU 能够更快的进行顺序访问，所以你可以在现代的硬件上用数组实现的列表，以获得更高的性能。数组可以顺序的保存数据。CPU 缓存能够一次加载数组的一大块进行缓存，一旦加载完成 CPU 就可以直接访问缓存中的数据。这对于元素散落在 RAM 中的链表来说，不太可能做得到。</p>
<h3 id="无状态的工作者"><a href="#无状态的工作者" class="headerlink" title="无状态的工作者"></a>无状态的工作者</h3><p>共享状态能够被系统中得其他线程修改。所以工作者在每次需要的时候必须重读状态，以确保每次都能访问到最新的副本，不管共享状态是保存在内存中的还是在外部数据库中。工作者无法在内部保存这个状态（但是每次需要的时候可以重读）称为无状态的。</p>
<p>每次都重读需要的数据，将会导致速度变慢，特别是状态保存在外部数据库中的时候。</p>
<h3 id="任务顺序是不确定的"><a href="#任务顺序是不确定的" class="headerlink" title="任务顺序是不确定的"></a>任务顺序是不确定的</h3><p>并行工作者模式的另一个缺点是，作业执行顺序是不确定的。无法保证哪个作业最先或者最后被执行。作业 A 可能在作业 B 之前就被分配工作者了，但是作业 B 反而有可能在作业A之前执行。</p>
<p>并行工作者模式的这种非确定性的特性，使得很难在任何特定的时间点推断系统的状态。这也使得它也更难（如果不是不可能的话）保证一个作业在其他作业之前被执行。</p>
<h2 id="流水线模式"><a href="#流水线模式" class="headerlink" title="流水线模式"></a>流水线模式</h2><p>第二种并发模型我们称之为流水线并发模型。我之所以选用这个名字，只是为了配合“并行工作者”的隐喻。其他开发者可能会根据平台或社区选择其他称呼（比如说反应器系统，或事件驱动系统）。下图表示一个流水线并发模型：</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/3.png" alt="img"></p>
<p>类似于工厂中生产线上的工人们那样组织工作者。每个工作者只负责作业中的部分工作。当完成了自己的这部分工作时工作者会将作业转发给下一个工作者。每个工作者在自己的线程中运行，并且不会和其他工作者共享状态。有时也被成为无共享并行模型。</p>
<p>通常使用非阻塞的 IO 来设计使用流水线并发模型的系统。非阻塞 IO 意味着，一旦某个工作者开始一个 IO 操作的时候（比如读取文件或从网络连接中读取数据），这个工作者不会一直等待 IO 操作的结束。IO 操作速度很慢，所以等待 IO 操作结束很浪费 CPU 时间。此时 CPU 可以做一些其他事情。当 IO 操作完成的时候，IO 操作的结果（比如读出的数据或者数据写完的状态）被传递给下一个工作者。</p>
<p>有了非阻塞 IO，就可以使用 IO 操作确定工作者之间的边界。工作者会尽可能多运行直到遇到并启动一个 IO 操作。然后交出作业的控制权。当 IO 操作完成的时候，在流水线上的下一个工作者继续进行操作，直到它也遇到并启动一个 IO 操作。</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/4.png" alt="img"></p>
<p>在实际应用中，作业有可能不会沿着单一流水线进行。由于大多数系统可以执行多个作业，作业从一个工作者流向另一个工作者取决于作业需要做的工作。在实际中可能会有多个不同的虚拟流水线同时运行。这是现实当中作业在流水线系统中可能的移动情况：</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/5.png" alt="img"></p>
<p>作业甚至也有可能被转发到超过一个工作者上并发处理。比如说，作业有可能被同时转发到作业执行器和作业日志器。下图说明了三条流水线是如何通过将作业转发给同一个工作者（中间流水线的最后一个工作者）来完成作业:</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/6.png" alt="img"></p>
<p>流水线有时候比这个情况更加复杂。</p>
<h3 id="反应器，事件驱动系统"><a href="#反应器，事件驱动系统" class="headerlink" title="反应器，事件驱动系统"></a>反应器，事件驱动系统</h3><p>采用流水线并发模型的系统有时候也称为反应器系统或事件驱动系统。系统内的工作者对系统内出现的事件做出反应，这些事件也有可能来自于外部世界或者发自其他工作者。事件可以是传入的 HTTP 请求，也可以是某个文件成功加载到内存中等。在写这篇文章的时候，已经有很多有趣的反应器/事件驱动平台可以使用了，并且不久的将来会有更多。比较流行的似乎是这几个：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/vert.x/index.html">Vert.x</a></li>
<li>AKKa</li>
<li>Node.JS(JavaScript)</li>
</ul>
<p>我个人觉得 Vert.x 是相当有趣的（特别是对于我这样使用 Java/JVM 的人来说）</p>
<h3 id="Actors-和-Channels"><a href="#Actors-和-Channels" class="headerlink" title="Actors 和 Channels"></a>Actors 和 Channels</h3><p>Actors 和 channels 是两种比较类似的流水线（或反应器/事件驱动）模型。</p>
<p>在 Actor 模型中每个工作者被称为 actor。Actor 之间可以直接异步地发送和处理消息。Actor 可以被用来实现一个或多个像前文描述的那样的作业处理流水线。下图给出了 Actor 模型：</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/7.png" alt="img"></p>
<p>而在 Channel 模型中，工作者之间不直接进行通信。相反，它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听。下图给出了 Channel 模型：</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/8.png" alt="img"></p>
<p>在写这篇文章的时候，channel 模型对于我来说似乎更加灵活。一个工作者无需知道谁在后面的流水线上处理作业。只需知道作业（或消息等）需要转发给哪个通道。通道上的监听者可以随意订阅或者取消订阅，并不会影响向这个通道发送消息的工作者。这使得工作者之间具有松散的耦合。</p>
<h2 id="流水线模型的优点"><a href="#流水线模型的优点" class="headerlink" title="流水线模型的优点"></a>流水线模型的优点</h2><p>相比并行工作者模型，流水线并发模型具有几个优点，在接下来的章节中我会介绍几个最大的优点。</p>
<h3 id="无需共享的状态"><a href="#无需共享的状态" class="headerlink" title="无需共享的状态"></a>无需共享的状态</h3><p>工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题。这使得在实现工作者的时候变得非常容易。在实现工作者的时候就好像是单个线程在处理工作-基本上是一个单线程的实现。</p>
<h3 id="有状态的工作者"><a href="#有状态的工作者" class="headerlink" title="有状态的工作者"></a>有状态的工作者</h3><p>当工作者知道了没有其他线程可以修改它们的数据，工作者可以变成有状态的。对于有状态，我是指，它们可以在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能。</p>
<h3 id="较好的硬件整合（Hardware-Conformity）"><a href="#较好的硬件整合（Hardware-Conformity）" class="headerlink" title="较好的硬件整合（Hardware Conformity）"></a>较好的硬件整合（Hardware Conformity）</h3><p>单线程代码在整合底层硬件的时候往往具有更好的优势。首先，当能确定代码只在单线程模式下执行的时候，通常能够创建更优化的数据结构和算法。</p>
<p>其次，像前文描述的那样，单线程有状态的工作者能够在内存中缓存数据。在内存中缓存数据的同时，也意味着数据很有可能也缓存在执行这个线程的 CPU 的缓存中。这使得访问缓存的数据变得更快。</p>
<p>我说的硬件整合是指，以某种方式编写的代码，使得能够自然地受益于底层硬件的工作原理。有些开发者称之为 mechanical sympathy。我更倾向于硬件整合这个术语，因为计算机只有很少的机械部件，并且能够隐喻“更好的匹配（match better）”，相比“同情（sympathy）”这个词在上下文中的意思，我觉得“conform”这个词表达的非常好。当然了，这里有点吹毛求疵了，用自己喜欢的术语就行。</p>
<h3 id="合理的作业顺序"><a href="#合理的作业顺序" class="headerlink" title="合理的作业顺序"></a>合理的作业顺序</h3><p>基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，你可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。按照特定的顺序将作业写入日志，并按这个顺序作为有保障的作业顺序。下图展示了一种可能的设计：</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/java-concurrent/images/8.png" alt="img"></p>
<p>实现一个有保障的作业顺序是不容易的，但往往是可行的。如果可以，它将大大简化一些任务，例如备份、数据恢复、数据复制等，这些都可以通过日志文件来完成。</p>
<h2 id="流水线模型的缺点"><a href="#流水线模型的缺点" class="headerlink" title="流水线模型的缺点"></a>流水线模型的缺点</h2><p>流水线并发模型最大的缺点是作业的执行往往分布到多个工作者上，并因此分布到项目中的多个类上。这样导致在追踪某个作业到底被什么代码执行时变得困难。</p>
<p>同样，这也加大了代码编写的难度。有时会将工作者的代码写成回调处理的形式。若在代码中嵌入过多的回调处理，往往会出现所谓的回调地狱（callback hell）现象。所谓回调地狱，就是意味着在追踪代码在回调过程中到底做了什么，以及确保每个回调只访问它需要的数据的时候，变得非常困难</p>
<p>使用并行工作者模型可以简化这个问题。你可以打开工作者的代码，从头到尾优美的阅读被执行的代码。当然并行工作者模式的代码也可能同样分布在不同的类中，但往往也能够很容易的从代码中分析执行的顺序。</p>
<h2 id="函数式并行（Functional-Parallelism）"><a href="#函数式并行（Functional-Parallelism）" class="headerlink" title="函数式并行（Functional Parallelism）"></a>函数式并行（Functional Parallelism）</h2><p>第三种并发模型是函数式并行模型，这是也最近（2015）讨论的比较多的一种模型。函数式并行的基本思想是采用函数调用实现程序。函数可以看作是”代理人（agents）“或者”actor“，函数之间可以像流水线模型（AKA 反应器或者事件驱动系统）那样互相发送消息。某个函数调用另一个函数，这个过程类似于消息发送。</p>
<p>函数都是通过拷贝来传递参数的，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要的。同样也使得函数的执行类似于原子操作。每个函数调用的执行独立于任何其他函数的调用。</p>
<p>一旦每个函数调用都可以独立的执行，它们就可以分散在不同的 CPU 上执行了。这也就意味着能够在多处理器上并行的执行使用函数式实现的算法。</p>
<p>Java7 中的 java.util.concurrent 包里包含的 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/java-fork-and-join-forkjoinpool.html">ForkAndJoinPool</a> 能够帮助我们实现类似于函数式并行的一些东西。而 Java8 中并行 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/java-fork-and-join-forkjoinpool.html">streams</a> 能够用来帮助我们并行的迭代大型集合。记住有些开发者对 ForkAndJoinPool 进行了批判（你可以在我的 ForkAndJoinPool 教程里面看到批评的链接）。</p>
<p>函数式并行里面最难的是确定需要并行的那个函数调用。跨 CPU 协调函数调用需要一定的开销。某个函数完成的工作单元需要达到某个大小以弥补这个开销。如果函数调用作用非常小，将它并行化可能比单线程、单 CPU 执行还慢。</p>
<p>我个人认为（可能不太正确），你可以使用反应器或者事件驱动模型实现一个算法，像函数式并行那样的方法实现工作的分解。使用事件驱动模型可以更精确的控制如何实现并行化（我的观点）。</p>
<p>此外，将任务拆分给多个 CPU 时协调造成的开销，仅仅在该任务是程序当前执行的唯一任务时才有意义。但是，如果当前系统正在执行多个其他的任务时（比如 web 服务器，数据库服务器或者很多其他类似的系统），将单个任务进行并行化是没有意义的。不管怎样计算机中的其他 CPU 们都在忙于处理其他任务，没有理由用一个慢的、函数式并行的任务去扰乱它们。使用流水线（反应器）并发模型可能会更好一点，因为它开销更小（在单线程模式下顺序执行）同时能更好的与底层硬件整合。</p>
<h2 id="使用那种并发模型最好？"><a href="#使用那种并发模型最好？" class="headerlink" title="使用那种并发模型最好？"></a>使用那种并发模型最好？</h2><p>所以，用哪种并发模型更好呢?</p>
<p>通常情况下，这个答案取决于你的系统打算做什么。如果你的作业本身就是并行的、独立的并且没有必要共享状态，你可能会使用并行工作者模型去实现你的系统。虽然许多作业都不是自然并行和独立的。对于这种类型的系统，我相信使用流水线并发模型能够更好的发挥它的优势，而且比并行工作者模型更有优势。</p>
<p>你甚至不用亲自编写所有流水线模型的基础结构。像 Vert.x 这种现代化的平台已经为你实现了很多。我也会去为探索如何设计我的下一个项目，使它运行在像 Vert.x 这样的优秀平台上。我感觉 Java EE 已经没有任何优势了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/20/java-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZP">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/20/java-concurrency/" class="post-title-link" itemprop="url">多线程Guide</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-20 15:22:02" itemprop="dateCreated datePublished" datetime="2020-07-20T15:22:02+08:00">2020-07-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-21 16:58:40" itemprop="dateModified" datetime="2020-07-21T16:58:40+08:00">2020-07-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Concurrency-Guide/" itemprop="url" rel="index"><span itemprop="name">Concurrency-Guide</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是多线程？"><a href="#什么是多线程？" class="headerlink" title="什么是多线程？"></a>什么是多线程？</h2><p>多线程意味着您在同一应用程序中具有多个<em>执行线程</em>。线程就像执行应用程序的独立CPU。因此，多线程应用程序就像具有多个CPU同时执行代码的不同部分的应用程序。</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" alt="在其中执行两个线程的应用程序。"></p>
<p>线程不等于CPU。通常，单个CPU将在多个线程之间共享其执行时间，并在给定的时间量内在每个线程之间执行切换。也可以使应用程序的线程由不同的CPU执行。</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" alt="具有线程由不同线程执行的多个应用程序。"></p>
<h2 id="为什么要多线程？"><a href="#为什么要多线程？" class="headerlink" title="为什么要多线程？"></a>为什么要多线程？</h2><p>为什么要在应用程序中使用多线程有多个原因。多线程的一些最常见原因是：</p>
<ul>
<li>更好地利用单个CPU。</li>
<li>更好地利用多个CPU或CPU内核。</li>
<li>更好的用户响应性体验。</li>
<li>更好的用户公平性体验。</li>
</ul>
<p>我将在以下各节中详细解释每个原因。</p>
<h3 id="更好地利用单个CPU"><a href="#更好地利用单个CPU" class="headerlink" title="更好地利用单个CPU"></a>更好地利用单个CPU</h3><p>最常见的原因之一是能够更好地利用计算机中的资源。例如，如果一个线程正在等待对通过网络发送的请求的响应，则另一线程可以同时使用CPU来执行其他操作。此外，如果计算机具有多个CPU，或者CPU具有多个执行核心，则多线程还可以帮助您的应用程序利用这些额外的CPU核心。</p>
<h3 id="更好地利用多个CPU或CPU内核"><a href="#更好地利用多个CPU或CPU内核" class="headerlink" title="更好地利用多个CPU或CPU内核"></a>更好地利用多个CPU或CPU内核</h3><p>如果计算机包含多个CPU或CPU包含多个执行核心，则您需要为应用程序使用多个线程才能使用所有CPU或CPU核心。单个线程最多只能使用一个CPU，如上所述，有时甚至不能完全利用单个CPU。</p>
<h3 id="更好的用户响应性体验"><a href="#更好的用户响应性体验" class="headerlink" title="更好的用户响应性体验"></a>更好的用户响应性体验</h3><p>使用多线程的另一个原因是为了提供更好的用户体验。例如，如果您单击GUI中的按钮，并导致通过网络发送请求，那么哪个线程执行此请求就很重要。如果您使用同一个线程去更新GUI，则在GUI线程等待请求响应时，用户可能会遇到GUI“挂起”的情况。取而代之，建议的做法为把这样的请求（发起网络请求）通过后台线程执行，因此GUI的那个线程可以自由地同时响应用户的请求。</p>
<h3 id="更好的用户公平性体验"><a href="#更好的用户公平性体验" class="headerlink" title="更好的用户公平性体验"></a>更好的用户公平性体验</h3><p>第四个原因是在用户之间更公平地共享计算机资源。例如，假设一台服务器接收来自客户端的请求，并且只有一个线程来执行这些请求。如果客户端发送的请求需要很长时间才能处理，则所有其他客户端的请求都必须等待，直到一个请求完成。通过使每个客户端的请求都由其自己的线程执行，则没有一个任务可以完全垄断CPU。</p>
<h2 id="多线程与多任务"><a href="#多线程与多任务" class="headerlink" title="多线程与多任务"></a>多线程与多任务</h2><p>过去，一台计算机只有一个CPU，并且一次只能执行一个程序。大多数小型计算机的功能实际上不足以同时执行多个程序，因此这些小型机也没有尝试过。公平地讲，许多大型机系统拥有能够一次执行多个程序的能力比个人计算机早很多年。</p>
<h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>后来出现了多任务处理，这意味着计算机可以同时执行多个程序（AKA任务或进程）。但是，这并不是真正的“同时”。单个CPU在程序之间共享。操作系统将在运行的程序之间进行切换，并在切换之前执行每个程序一会儿。</p>
<p>随着多任务处理，软件开发人员面临着新的挑战。程序不再假定拥有所有可用的CPU时间，也不拥有所有的内存或任何其他计算机资源。一个“好公民”程序应释放不再使用的所有资源，以便其他程序可以使用它们。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>后来又出现了多线程，这意味着您可以在同一程序中拥有多个执行线程。可以将一个执行线程视为一个CPU执行的程序。当有多个线程执行同一程序时，就像在同一程序里有多个CPU执行它。</p>
<h2 id="多线程很难"><a href="#多线程很难" class="headerlink" title="多线程很难"></a>多线程很难</h2><p>多线程是提高某些类型程序性能的好方法。但是，多线程处理比多任务处理更具挑战性。这些线程在同一程序中执行，因此同时在读取和写入相同的内存。这可能会导致在单线程程序中看不到的错误。在单个CPU机器上可能看不到其中一些错误，因为两个线程从未真正“同时”执行。但是，现代计算机配备了多核CPU，甚至还配备了多个CPU。这意味着可以由单独的内核或CPU同时执行单独的线程。</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" alt="多CPU计算机上的多线程"></p>
<p>如果一个线程读取了另一个线程正在写入的内存位置，那么读线程最终将读取什么值？旧值？写线程写的值？还是两者之间混合的值？或者，如果两个线程同时写入相同的内存位置，完成后将剩下什么值？由第一个线程写的值？第二个线程写的值？还是两个值的混合编写？</p>
<p>没有适当的预防措施，任何这些结果都是可能的。该行为甚至是不可预测的。结果可能会不时改变。因此，作为开发人员，重要的是要知道如何采取正确的预防措施-意味着学习控制线程如何访问共享资源（如内存，文件，数据库等）。这是本Java并发性教程解决的主题之一。</p>
<h2 id="Java中的多线程和并发"><a href="#Java中的多线程和并发" class="headerlink" title="Java中的多线程和并发"></a>Java中的多线程和并发</h2><p>Java是最早使开发人员可以使用多线程的语言之一。Java从一开始就具有多线程功能。因此，Java开发人员经常面临上述问题。这就是我在Java并发上编写此捷径的原因。谨此提醒自己，以及可能从中受益的其他Java开发人员。</p>
<p>本教程主要关注Java中的多线程，但有些在多线程中出现的问题会和多任务以及分布式系统中出现的存在类似，因此该系列会将多任务和分布式系统方面作为参考，所以叫法上称为“并发性”，而不是“多线程”。</p>
<h2 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h2><p>第一个Java <em>并发模型</em>假定在同一应用程序中执行的多个线程也将共享对象。这种类型的并发模型通常称为“共享状态并发模型”。许多并发语言构造和实用程序旨在支持这种并发模型。</p>
<p>但是，自从编写第一本Java并发书籍以来，甚至自Java 5并发实用工具发布以来，并发体系结构和设计领域已经发生了很多事情。</p>
<p>共享状态并发模型导致许多并发问题，这些问题很难优雅地解决。因此，被称为“无共享”或“分离状态”的替代并发模型已经普及。在单独或者分离状态得并发模型中，线程不共享任何对象或数据。这避免了共享状态下并发模型的许多并发访问问题。</p>
<p>出现了新的异步“分离状态”的平台和工具包，例如Netty，Vert.x和Play / Akka和Qbit(就听过netty囧)。新的非阻塞并发算法已经发布，并且新的非阻塞工具（例如LMax Disrupter）已添加到我们的工具箱中。Java 7中的Fork and Join框架和Java 8中的collection stream API引入了新的函数式编程并行性。</p>
<p>通过所有这些新开发，现在是时候更新本Java Concurrency教程了。因此，本教程再次<strong>进行中</strong>。只要有时间编写新教程，它们就会发布。</p>
<h2 id="Java并发学习指南"><a href="#Java并发学习指南" class="headerlink" title="Java并发学习指南"></a>Java并发学习指南</h2><p>如果您不熟悉Java并发，建议您遵循以下学习计划。您也可以在此页面左侧的菜单中找到所有主题的链接。</p>
<p>通用并发和多线程理论：</p>
<ul>
<li><a href="/2020/07/20/benifits/" title="多线程的好处">多线程的好处</a></li>
<li><a href="/2020/07/20/costs/" title="多线程成本">多线程成本</a></li>
<li><a href="/2020/07/20/concurrency-models/" title="并发模型">并发模型</a></li>
<li><a href="/2020/07/20/same-threading/" title="同一线程">同一线程</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html">并发与并行</a></li>
</ul>
<p>Java并发基础知识：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html">创建和启动Java线程</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html">比赛条件和关键部分</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/thread-safety.html">线程安全和共享资源</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/thread-safety-and-immutability.html">线程安全性和不变性</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">Java内存模型</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/synchronized.html">Java同步块</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/volatile.html">Java易失性关键字</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/threadlocal.html">Java ThreadLocal</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/thread-signaling.html">Java线程信令</a></li>
</ul>
<p>Java并发性的典型问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/deadlock.html">僵局</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html">防止死锁</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html">饥饿与公平</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/nested-monitor-lockout.html">嵌套监视器锁定</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/slipped-conditions.html">滑倒条件</a></li>
</ul>
<p>Java并发构造可帮助解决上述问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/locks.html">Java锁</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html">Java中的读/写锁</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/reentrance-lockout.html">重入锁定</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/semaphores.html">信号量</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html">阻塞队列</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/thread-pools.html">线程池</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html">比较和交换</a></li>
</ul>
<p>Java并发实用程序（java.util.concurrent）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/index.html">Java并发实用程序-java.util.concurrent</a></li>
</ul>
<p>进一步的主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/anatomy-of-a-synchronizer.html">同步器的解剖</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html">非阻塞算法</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/amdahls-law.html">阿姆达尔定律</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/references.html">参考资料</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/14/%E3%80%8A%20JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZP">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/14/%E3%80%8A%20JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%8B/" class="post-title-link" itemprop="url">《JAVA并发编程》</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-14 10:11:32" itemprop="dateCreated datePublished" datetime="2020-07-14T10:11:32+08:00">2020-07-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-20 16:59:55" itemprop="dateModified" datetime="2020-07-20T16:59:55+08:00">2020-07-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《-JAVA并发编程》"><a href="#《-JAVA并发编程》" class="headerlink" title="《 JAVA并发编程》"></a>《 JAVA并发编程》</h1><h2 id="并发性与多线程介绍"><a href="#并发性与多线程介绍" class="headerlink" title="并发性与多线程介绍"></a>并发性与多线程介绍</h2><p>在过去单 CPU 时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个 CPU，并交由操作系统来完成多任务间对 CPU 的运行切换，以使得每个任务都有机会获得一定的时间片运行。</p>
<hr>
<p>随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。</p>
<hr>
<p>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个 CPU 在执行该程序。当一个程序运行在多线程下，就好像有多个 CPU 在同时执行该程序。<br>多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单 CPU 机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的 CPU 核得到真正意义的并行执行。</p>
<hr>
<p>如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。</p>
<h3 id="Java-的多线程和并发性"><a href="#Java-的多线程和并发性" class="headerlink" title="Java 的多线程和并发性"></a>Java 的多线程和并发性</h3><p>Java 是最先支持多线程的开发的语言之一，Java 从一开始就支持了多线程能力，因此 Java 开发者能常遇到上面描述的问题场景。这也是我想为 Java 并发技术而写这篇系列的原因。作为对自己的笔记，和对其他 Java 开发的追随者都可获益的。<br>该系列主要关注 Java 多线程，但有些在多线程中出现的问题会和多任务以及分布式系统中出现的存在类似，因此该系列会将多任务和分布式系统方面作为参考，所以叫法上称为“并发性”，而不是“多线程”。</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><h3 id="使用-interrupt-中断线程"><a href="#使用-interrupt-中断线程" class="headerlink" title="使用 interrupt()中断线程"></a>使用 interrupt()中断线程</h3><p>当一个线程运行时，另一个线程可以调用对应的 Thread 对象的 interrupt()方法来中断它，该方法只是在目标线程中设置一个标志，表示它已经被中断，并立即返回。这里需要注意的是，如果只是单纯的调用 interrupt()方法，线程并没有实际被中断，会继续往下执行。<br>下面一段代码演示了休眠线程的中断:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;in run() - about to sleep for 20 seconds&quot;</span>);  </span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;in run() - woke up&quot;</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;in run() - interrupted while sleeping&quot;</span>);  </span><br><span class="line">            <span class="comment">//处理完中断异常后，返回到run（）方法人口，  </span></span><br><span class="line">            <span class="comment">//如果没有return，线程不会实际被中断，它会继续打印下面的信息  </span></span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;in run() - leaving normally&quot;</span>);  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    SleepInterrupt si = <span class="keyword">new</span> SleepInterrupt();  </span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(si);  </span><br><span class="line">    t.start();  </span><br><span class="line">    <span class="comment">//主线程休眠2秒，从而确保刚才启动的线程有机会执行一段时间  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);   </span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">&quot;in main() - interrupting other thread&quot;</span>);  </span><br><span class="line">    <span class="comment">//中断线程t  </span></span><br><span class="line">    t.interrupt();  </span><br><span class="line">    System.out.println(<span class="string">&quot;in main() - leaving&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/TIM%E6%88%AA%E5%9B%BE20200714141526.png" style="zoom:150%;" />

<p>主线程启动新线程后，自身休眠 2 秒钟，允许新线程获得运行时间。新线程打印信息about to sleep for 20 seconds后，继而休眠 20 秒钟，大约 2 秒钟后，main 线程通知新线程中断，那么新线程的 20 秒的休眠将被打断，从而抛出  InterruptedException 异常，执行跳转到 catch 块，打印出interrupted while sleeping信息，并立即从 run（）方法返回，然后消亡，而不会打印出 catch 块后面的leaving normally信息。</p>
<hr>
<p><em>请注意</em>：由于不确定的线程规划，上图运行结果的后两行可能顺序相反，这取决于主线程和新线程哪个先消亡。但前两行信息的顺序必定如上图所示。另外，如果将 catch 块中的 return 语句注释掉，则线程在抛出异常后，会继续往下执行，而不会被中断，从而会打印出<br>leaving normally信息。</p>
<hr>
<h3 id="待决中断"><a href="#待决中断" class="headerlink" title="待决中断"></a>待决中断</h3><p>在上面的例子中，sleep()方法的实现检查到休眠线程被中断，它会相当友好地终止线程，并抛出 InterruptedException 异常。另外一种情况，如果线程在调用 sleep()方法前被中断，那么该中断称为待决中断，它会在刚调用 sleep()方法时，立即抛出 InterruptedException 异常。<br>下面的代码演示了待决中断:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingInterrupt</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//如果输入了参数，则在mian线程中中断当前线程（亦即main线程）  </span></span><br><span class="line">        <span class="keyword">if</span>( args.length &gt; <span class="number">0</span> )&#123;  </span><br><span class="line">            Thread.currentThread().interrupt();  </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//获取当前时间  </span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;was NOT interrupted&quot;</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException x)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;was interrupted&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//计算中间代码执行的时间  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;elapsedTime=&quot;</span> + ( System.currentTimeMillis() - startTime));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果 PendingInterrupt 不带任何命令行参数，那么线程不会被中断，最终输出的时间差距应该在 2000 附近（具体时间由系统决定，不精确），如果 PendingInterrupt 带有命令行参数，则调用中断当前线程的代码，但 main 线程仍然运行，最终输出的时间差距应该远小于 2000，因为线程尚未休眠，便被中断，因此，一旦调用 sleep()方法，会立即打印出 catch 块中的信息。</p>
<p>执行结果如下:</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/TIM%E6%88%AA%E5%9B%BE20200714141953.png" style="zoom:150%;" />

<p>这种模式下，main 线程中断它自身。除了将中断标志（它是 Thread 的内部标志）设置为 true 外，没有其他任何影响。线程被中断了，但 main 线程仍然运行，main 线程继续监视实时时钟，并进入 try 块，一旦调用 sleep（）方法，它就会注意到待决中断的存在，并抛出 InterruptException。于是执行跳转到 catch 块，并打印出线程被中断的信息。最后，计算并打印出时间差。使用 isInterrupted()方法判断中断状态可以在 Thread 对象上调用 isInterrupted()方法来检查任何线程的中断状态。</p>
<p>这里需要注意：线程一旦被中断，isInterrupted()方法便会返回 true，而一旦 sleep()方法抛出异常，它将清空中断标志，此时isInterrupted()方法将返回 false。</p>
<p>下面的代码演示了 isInterrupted()方法的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptCheck</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Thread t = Thread.currentThread();  </span><br><span class="line">        System.out.println(<span class="string">&quot;Point A: t.isInterrupted()=&quot;</span> + t.isInterrupted());  </span><br><span class="line">        <span class="comment">//待决中断，中断自身  </span></span><br><span class="line">        t.interrupt();  </span><br><span class="line">        System.out.println(<span class="string">&quot;Point B: t.isInterrupted()=&quot;</span> + t.isInterrupted());  </span><br><span class="line">        System.out.println(<span class="string">&quot;Point C: t.isInterrupted()=&quot;</span> + t.isInterrupted());  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;was NOT interrupted&quot;</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span>( InterruptedException x)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;was interrupted&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//抛出异常后，会清除中断标志，这里会返回false  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Point D: t.isInterrupted()=&quot;</span> + t.isInterrupted());  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果如下： </p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/TIM%E6%88%AA%E5%9B%BE20200714142142.png" style="zoom:150%;" />



<h3 id="使用-Thread-interrupted-方法判断中断状态"><a href="#使用-Thread-interrupted-方法判断中断状态" class="headerlink" title="使用 Thread.interrupted()方法判断中断状态"></a>使用 Thread.interrupted()方法判断中断状态</h3><hr>
<p>可以使用 Thread.interrupted()方法来检查当前线程的中断状态（并隐式重置为 false）。又由于它是静态方法，因此不能在特定的线程上使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回 true。与 isInterrupted()不同，它将自动重置中断状态为 false，第二次调用 Thread.interrupted()方法，总是返回 false，除非中断了线程。<br>如下代码演示了 Thread.interrupted()方法的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptReset</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(  </span><br><span class="line">            <span class="string">&quot;Point X: Thread.interrupted()=&quot;</span> + Thread.interrupted());  </span><br><span class="line">        Thread.currentThread().interrupt();  </span><br><span class="line">        System.out.println(  </span><br><span class="line">            <span class="string">&quot;Point Y: Thread.interrupted()=&quot;</span> + Thread.interrupted());  </span><br><span class="line">        System.out.println(  </span><br><span class="line">            <span class="string">&quot;Point Z: Thread.interrupted()=&quot;</span> + Thread.interrupted());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/TIM%E6%88%AA%E5%9B%BE20200714142259.png" style="zoom:150%;" />

<p>从结果中可以看出，当前线程中断自身后，在 Y 点，中断状态为 true，并由 Thread.interrupted()自动重置为 false，那么下次调用该方法得到的结果便是 false。</p>
<hr>
<p>补充：</p>
<p>这里补充下 yield 和 join 方法的使用。<br>⦁    join 方法用线程对象调用，如果在一个线程 A 中调用另一个线程 B 的 join 方法，线程 A 将会等待线程 B 执行完毕后再执行。<br>⦁    yield 可以直接用 Thread 类调用，yield 让出 CPU 执行权给同等级的线程，如果没有相同级别的线程在等待 CPU 的执行权，则该线程继续执行。</p>
<h2 id="线程挂起、恢复与终止"><a href="#线程挂起、恢复与终止" class="headerlink" title="线程挂起、恢复与终止"></a>线程挂起、恢复与终止</h2><h3 id="挂起和恢复线程"><a href="#挂起和恢复线程" class="headerlink" title="挂起和恢复线程"></a>挂起和恢复线程</h3><p>Thread 的 API 中包含两个被淘汰的方法，它们用于临时挂起和重启某个线程，这些方法已经被淘汰，因为它们是不安全的，不稳定的。如果在不合适的时候挂起线程（比如，锁定共享资源时），此时便可能会发生死锁条件——其他线程在等待该线程释放锁，但该线程却被挂起了，便会发生死锁。另外，在长时间计算期间挂起线程也可能导致问题。<br>下面的代码演示了通过休眠来延缓运行，模拟长时间运行的情况，使线程更可能在不适当的时候被挂起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeprecatedSuspendResume</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//volatile关键字，表示该变量可能在被一个线程使用的同时，被另一个线程修改  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> firstVal;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> secondVal;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断二者是否相等  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areValuesEqual</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> ( firstVal == secondVal);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            firstVal = <span class="number">0</span>;  </span><br><span class="line">            secondVal = <span class="number">0</span>;  </span><br><span class="line">            workMethod();  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException x)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted while in workMethod()&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">workMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;  </span><br><span class="line">            stepOne(val);  </span><br><span class="line">            stepTwo(val);  </span><br><span class="line">            val++;  </span><br><span class="line">            Thread.sleep(<span class="number">200</span>);  <span class="comment">//再次循环钱休眠200毫秒  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值后，休眠300毫秒，从而使线程有机会在stepOne操作和stepTwo操作之间被挂起  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stepOne</span><span class="params">(<span class="keyword">int</span> newVal)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;  </span><br><span class="line">        firstVal = newVal;  </span><br><span class="line">        Thread.sleep(<span class="number">300</span>);  <span class="comment">//模拟长时间运行的情况  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stepTwo</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>&#123;  </span><br><span class="line">        secondVal = newVal;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        DeprecatedSuspendResume dsr = <span class="keyword">new</span> DeprecatedSuspendResume();  </span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(dsr);  </span><br><span class="line">        t.start();  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//休眠1秒，让其他线程有机会获得执行  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);&#125;   </span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException x)&#123;&#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;  </span><br><span class="line">            <span class="comment">//挂起线程  </span></span><br><span class="line">            t.suspend();  </span><br><span class="line">            System.out.println(<span class="string">&quot;dsr.areValuesEqual()=&quot;</span> + dsr.areValuesEqual());  </span><br><span class="line">            <span class="comment">//恢复线程  </span></span><br><span class="line">            t.resume();  </span><br><span class="line">            <span class="keyword">try</span>&#123;   </span><br><span class="line">                <span class="comment">//线程随机休眠0~2秒  </span></span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">2000.0</span>));  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException x)&#123;  </span><br><span class="line">                <span class="comment">//略  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">//中断应用程序  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>运行结果如下：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/14.png" style="zoom:150%;" />

<p>从 areValuesEqual()返回的值有时为 true，有时为 false。以上代码中，在设置 firstVal 之后，但在设置 secondVal 之前，挂起新线程会产生麻烦，此时输出的结果会为 false（情况 1），这段时间不适宜挂起线程，但因为线程不能控制何时调用它的 suspend 方法，所以这种情况是不可避免的。</p>
<p>当然，即使线程不被挂起（注释掉挂起和恢复线程的两行代码），如果在 main 线程中执行 asr.areValuesEqual()进行比较时，恰逢 stepOne 操作执行完，而 stepTwo 操作还没执行，那么得到的结果同样可能是 false（情况 2）。</p>
<p>下面我们给出不用上述两个方法来实现线程挂起和恢复的策略——设置标志位。通过该方法实现线程的挂起和恢复有一个很好的地方，就是可以在线程的指定位置实现线程的挂起和恢复，而不用担心其不确定性。<br>对于上述代码的改进代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlternateSuspendResume</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> firstVal;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> secondVal;  </span><br><span class="line">    <span class="comment">//增加标志位，用来实现线程的挂起和恢复  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> suspended;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areValuesEqual</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> ( firstVal == secondVal );  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            suspended = <span class="keyword">false</span>;  </span><br><span class="line">            firstVal = <span class="number">0</span>;  </span><br><span class="line">            secondVal = <span class="number">0</span>;  </span><br><span class="line">            workMethod();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> ( InterruptedException x ) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted while in workMethod()&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">workMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">1</span>;  </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> ( <span class="keyword">true</span> ) &#123;  </span><br><span class="line">            <span class="comment">//仅当贤臣挂起时，才运行这行代码  </span></span><br><span class="line">            waitWhileSuspended();   </span><br><span class="line">    </span><br><span class="line">            stepOne(val);  </span><br><span class="line">            stepTwo(val);  </span><br><span class="line">            val++;  </span><br><span class="line">    </span><br><span class="line">            <span class="comment">//仅当线程挂起时，才运行这行代码  </span></span><br><span class="line">            waitWhileSuspended();   </span><br><span class="line">    </span><br><span class="line">            Thread.sleep(<span class="number">200</span>);    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stepOne</span><span class="params">(<span class="keyword">int</span> newVal)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        firstVal = newVal;  </span><br><span class="line">        Thread.sleep(<span class="number">300</span>);    </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stepTwo</span><span class="params">(<span class="keyword">int</span> newVal)</span> </span>&#123;  </span><br><span class="line">        secondVal = newVal;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspendRequest</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        suspended = <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeRequest</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        suspended = <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitWhileSuspended</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//这是一个“繁忙等待”技术的示例。  </span></span><br><span class="line">        <span class="comment">//它是非等待条件改变的最佳途径，因为它会不断请求处理器周期地执行检查，   </span></span><br><span class="line">        <span class="comment">//更佳的技术是：使用Java的内置“通知-等待”机制  </span></span><br><span class="line">        <span class="keyword">while</span> ( suspended ) &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">200</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        AlternateSuspendResume asr =   </span><br><span class="line">                <span class="keyword">new</span> AlternateSuspendResume();  </span><br><span class="line">    </span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(asr);  </span><br><span class="line">        t.start();  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//休眠1秒，让其他线程有机会获得执行  </span></span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125;   </span><br><span class="line">        <span class="keyword">catch</span> ( InterruptedException x ) &#123; &#125;  </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;  </span><br><span class="line">            asr.suspendRequest();  </span><br><span class="line">    </span><br><span class="line">            <span class="comment">//让线程有机会注意到挂起请求  </span></span><br><span class="line">            <span class="comment">//注意：这里休眠时间一定要大于  </span></span><br><span class="line">            <span class="comment">//stepOne操作对firstVal赋值后的休眠时间，即300ms，  </span></span><br><span class="line">            <span class="comment">//目的是为了防止在执行asr.areValuesEqual（）进行比较时,  </span></span><br><span class="line">            <span class="comment">//恰逢stepOne操作执行完，而stepTwo操作还没执行  </span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">350</span>); &#125;   </span><br><span class="line">            <span class="keyword">catch</span> ( InterruptedException x ) &#123; &#125;  </span><br><span class="line">    </span><br><span class="line">            System.out.println(<span class="string">&quot;dsr.areValuesEqual()=&quot;</span> +   </span><br><span class="line">                    asr.areValuesEqual());  </span><br><span class="line">    </span><br><span class="line">            asr.resumeRequest();  </span><br><span class="line">    </span><br><span class="line">            <span class="keyword">try</span> &#123;   </span><br><span class="line">                <span class="comment">//线程随机休眠0~2秒  </span></span><br><span class="line">                Thread.sleep(  </span><br><span class="line">                        ( <span class="keyword">long</span> ) (Math.random() * <span class="number">2000.0</span>) );  </span><br><span class="line">            &#125; <span class="keyword">catch</span> ( InterruptedException x ) &#123;  </span><br><span class="line">                <span class="comment">//略  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    </span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">//退出应用程序  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>运行结果如下：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/15.png" style="zoom:150%;" />



<p>由结果可以看出，输出的所有结果均为 true。首先，针对情况 1（线程挂起的位置不确定），这里确定了线程挂起的位置，不会出现线程在 stepOne 操作和 stepTwo 操作之间挂起的情况；针对情况 2（main 线程中执行asr.areValuesEqual()进行比较时，恰逢 stepOne 操作执行完，而 stepTwo 操作还没执行），在发出挂起请求后，还没有执行 asr.areValuesEqual()操作前，让 main 线程休眠 450ms（&gt;300ms），如果挂起请求发出时，新线程正执行到或即将执行到 stepOne 操作（如果在其前面的话，就会响应挂起请求，从而挂起线程），那么在 stepTwo 操作执行前，main 线程的休眠还没结束，从而 main 线程休眠结束后执行 asr.areValuesEqualv操作进行比较时，stepTwo 操作已经执行完，因此也不会出现输出结果为 false 的情况。<br>可以将 ars.suspendRequest()代码后的 sleep 代码去掉，或将休眠时间改为 200（明显小于 300 即可）后，查看执行结果，会发现结果中依然会有出现 false 的情况。</p>
<p>如下图所示：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/22.png" style="zoom:150%;" />



<p><strong>总结：线程的挂起和恢复实现的正确方法是：通过设置标志位，让线程在安全的位置挂起。</strong></p>
<hr>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>当调用 Thread 的 start()方法，执行完 run()方法后，或在 run()方法中 return，线程便会自然消亡。另外 Thread API 中包含了一个 stop()方法，可以突然终止线程。但它在 JDK1.2 后便被淘汰了，因为它可能导致数据对象的崩溃。一个问题是，当线程终止时，很少有机会执行清理工作；另一个问题是，当在某个线程上调用 stop()方法时，线程释放它当前持有的所有锁，持有这些锁必定有某种合适的理由——也许是阻止其他线程访问尚未处于一致性状态的数据，突然释放锁可能使某些对象中的数据处于不一致状态，而且不会出现数据可能崩溃的任何警告。<br>终止线程的替代方法：同样是使用标志位，通过控制标志位来终止线程。</p>
<h2 id="守护线程与线程阻塞"><a href="#守护线程与线程阻塞" class="headerlink" title="守护线程与线程阻塞"></a>守护线程与线程阻塞</h2><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Java 中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)</p>
<p>用户线程即运行在前台的线程，而守护线程是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。当 VM 检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出，因为没有如果没有了被守护这，也就没有继续运行程序的必要了。如果有非守护线程仍然存活，VM 就不会退出。</p>
<p>守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用 Thread 的 setDaemon（true）方法设置当前线程为守护线程。</p>
<p>虽然守护线程可能非常有用，但必须小心确保其他所有非守护线程消亡时，不会由于它的终止而产生任何危害。因为你不可能知道在所有的用户线程退出运行前，守护线程是否已经完成了预期的服务任务。一旦所有的用户线程退出了，虚拟机也就退出运行了。 因此，不要在守护线程中执行业务逻辑操作（比如对数据的读写等）。</p>
<p>另外有几点需要注意：<br>⦁    setDaemon(true)必须在调用线程的 start()方法之前设置，否则会跑出 IllegalThreadStateException 异常。<br>⦁    在守护线程中产生的新线程也是守护线程。<br>⦁    不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</p>
<h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><p>线程可以阻塞于四种状态：<br>⦁    当线程执行 Thread.sleep()时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断；<br>⦁    当线程碰到一条 wait()语句时，它会一直阻塞到接到通知（notify()）、被中断或经过了指定毫秒时间为止（若制定了超时值的话）<br>⦁    线程阻塞与不同 I/O 的方式有多种。常见的一种方式是 InputStream的read()方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；<br>⦁    线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得 synchronized 语句必须的锁时阻塞）。<br>注意，并非所有的阻塞状态都是可中断的，以上阻塞状态的前两种可以被中断，后两种不会对中断做出反应</p>
<h2 id="Volatile-关键字（上）"><a href="#Volatile-关键字（上）" class="headerlink" title="Volatile 关键字（上）"></a>Volatile 关键字（上）</h2><h3 id="volatile-用处说明"><a href="#volatile-用处说明" class="headerlink" title="volatile 用处说明"></a>volatile 用处说明</h3><p>在 JDK1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而随着 JVM 的成熟和优化，现在在多线程环境下 volatile 关键字的使用变得非常重要。</p>
<p>在当前的 Java 内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下，各任务间共享的变量都应该加 volatile 修饰符。</p>
<p>Volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>Java 语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才将私有拷贝与共享内存中的原始值进行比较。这样当多个线程同时与某个对象交互时，就必须注意到要让线程及时的得到共享成员变量的变化。而 volatile 关键字就是提示 JVM：对于这个成员变量，不能保存它的私有拷贝，而应直接与共享成员变量交互。volatile 是一种稍弱的同步机制，在访问 volatile 变量时不会执行加锁操作，也就不会执行线程阻塞，因此 volatilei 变量是一种比 synchronized 关键字更轻量级的同步机制。</p>
<p>使用建议：在两个或者更多的线程需要访问的成员变量上使用 volatile。当要访问的变量已在 synchronized 代码块中，或者为常量时，没必要使用 volatile。由于使用 volatile 屏蔽掉了 JVM 中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p>
<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>下面给出一段代码，通过其运行结果来说明使用关键字 volatile 产生的差异，但实际上遇到了意料之外的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//value变量没有被标记为volatile  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;    </span><br><span class="line">    <span class="comment">//missedIt变量被标记为volatile  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> missedIt;  </span><br><span class="line">    <span class="comment">//creationTime不需要声明为volatile，因为代码执行中它没有发生变化  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> creationTime;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Volatile</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        value = <span class="number">10</span>;  </span><br><span class="line">        missedIt = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="comment">//获取当前时间，亦即调用Volatile构造函数时的时间  </span></span><br><span class="line">        creationTime = System.currentTimeMillis();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        print(<span class="string">&quot;entering run()&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//循环检查value的值是否不同  </span></span><br><span class="line">        <span class="keyword">while</span> ( value &lt; <span class="number">20</span> ) &#123;  </span><br><span class="line">            <span class="comment">//如果missedIt的值被修改为true，则通过break退出循环  </span></span><br><span class="line">            <span class="keyword">if</span>  ( missedIt ) &#123;  </span><br><span class="line">                <span class="comment">//进入同步代码块前，将value的值赋给currValue  </span></span><br><span class="line">                <span class="keyword">int</span> currValue = value;  </span><br><span class="line">                <span class="comment">//在一个任意对象上执行同步语句，目的是为了让该线程在进入和离开同步代码块时，  </span></span><br><span class="line">                <span class="comment">//将该线程中的所有变量的私有拷贝与共享内存中的原始值进行比较，  </span></span><br><span class="line">                <span class="comment">//从而发现没有用volatile标记的变量所发生的变化  </span></span><br><span class="line">                Object lock = <span class="keyword">new</span> Object();  </span><br><span class="line">                <span class="keyword">synchronized</span> ( lock ) &#123;  </span><br><span class="line">                    <span class="comment">//不做任何事  </span></span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//离开同步代码块后，将此时value的值赋给valueAfterSync  </span></span><br><span class="line">                <span class="keyword">int</span> valueAfterSync = value;  </span><br><span class="line">                print(<span class="string">&quot;in run() - see value=&quot;</span> + currValue +<span class="string">&quot;, but rumor has it that it changed!&quot;</span>);  </span><br><span class="line">                print(<span class="string">&quot;in run() - valueAfterSync=&quot;</span> + valueAfterSync);  </span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        print(<span class="string">&quot;leaving run()&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        print(<span class="string">&quot;entering workMethod()&quot;</span>);  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - about to sleep for 2 seconds&quot;</span>);  </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        <span class="comment">//仅在此改变value的值  </span></span><br><span class="line">        value = <span class="number">50</span>;  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - just set value=&quot;</span> + value);  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - about to sleep for 5 seconds&quot;</span>);  </span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        <span class="comment">//仅在此改变missedIt的值  </span></span><br><span class="line">        missedIt = <span class="keyword">true</span>;  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - just set missedIt=&quot;</span> + missedIt);  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - about to sleep for 3 seconds&quot;</span>);  </span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);  </span><br><span class="line">        print(<span class="string">&quot;leaving workMethod()&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    *该方法的功能是在要打印的msg信息前打印出程序执行到此所化去的时间，以及打印msg的代码所在的线程 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//使用java.text包的功能，可以简化这个方法，但是这里没有利用这一点  </span></span><br><span class="line">        <span class="keyword">long</span> interval = System.currentTimeMillis() - creationTime;  </span><br><span class="line">        String tmpStr = <span class="string">&quot;    &quot;</span> + ( interval / <span class="number">1000.0</span> ) + <span class="string">&quot;000&quot;</span>;       </span><br><span class="line">        <span class="keyword">int</span> pos = tmpStr.indexOf(<span class="string">&quot;.&quot;</span>);  </span><br><span class="line">        String secStr = tmpStr.substring(pos - <span class="number">2</span>, pos + <span class="number">4</span>);  </span><br><span class="line">        String nameStr = <span class="string">&quot;        &quot;</span> + Thread.currentThread().getName();  </span><br><span class="line">        nameStr = nameStr.substring(nameStr.length() - <span class="number">8</span>, nameStr.length());      </span><br><span class="line">        System.out.println(secStr + <span class="string">&quot; &quot;</span> + nameStr + <span class="string">&quot;: &quot;</span> + msg);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//通过该构造函数可以获取实时时钟的当前时间  </span></span><br><span class="line">            Volatile vol = <span class="keyword">new</span> Volatile();  </span><br><span class="line">    </span><br><span class="line">            <span class="comment">//稍停100ms，以让实时时钟稍稍超前获取时间，使print（）中创建的消息打印的时间值大于0  </span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);    </span><br><span class="line">    </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(vol);  </span><br><span class="line">            t.start();  </span><br><span class="line">    </span><br><span class="line">            <span class="comment">//休眠100ms，让刚刚启动的线程有时间运行  </span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);    </span><br><span class="line">            <span class="comment">//workMethod方法在main线程中运行  </span></span><br><span class="line">            vol.workMethod();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> ( InterruptedException x ) &#123;  </span><br><span class="line">            System.err.println(<span class="string">&quot;one of the sleeps was interrupted&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>按照以上的理论来分析，由于 value 变量不是 volatile 的，因此它在 main 线程中的改变不会被 Thread-0 线程（在 main 线程中新开启的线程）马上看到，因此 Thread-0 线程中的 while 循环不会直接退出，它会继续判断 missedIt 的值，由于 missedIt 是 volatile 的，当 main 线程中改变了 missedIt 时，Thread-0 线程会立即看到该变化，那么 if 语句中的代码便得到了执行的机会，由于此时 Thread-0 依然没有看到 value 值的变化，因此，currValue 的值为 10，继续向下执行，进入同步代码块，因为进入前后要将该线程内的变量值与共享内存中的原始值对比，进行校准，因此离开同步代码块后，Thread-0 便会察觉到 value 的值变为了 50，那么后面的 valueAfterSync 的值便为 50，最后从 break 跳出循环，结束 Thread-0 线程。</p>
<blockquote>
<h3 id="意料之外的问题"><a href="#意料之外的问题" class="headerlink" title="意料之外的问题"></a>意料之外的问题</h3><p>但实际的执行结果如下：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/55.png" style="zoom:150%;" />

<p>从结果中可以看出，Thread-0 线程并没有进入 while 循环，说明 Thread-0 线程在 value 的值发生变化后，missedIt 的值发生变化前，便察觉到了 value 值的变化，从而退出了 while 循环。这与理论上的分析不符，我便尝试注释掉 value 值发生改变与 missedIt 值发生改变之间的线程休眠代码 Thread.sleep(5000)，以确保Thread-0 线程在 missedIt 的值发生改变前，没有时间察觉到 value 值的变化。但执行的结果与上面大同小异（可能有一两行顺序不同，但依然不会打印出 if 语句中的输出信息）。</p>
</blockquote>
<blockquote>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在 JDK1.7~JDK1.3 之间的版本上输出结果与上面基本大同小异，只有在 JDK1.2 上才得到了预期的结果，即Thread-0 线程中的 while 循环是从 if 语句中退出的，这说明 Thread-0 线程没有及时察觉到 value 值的变化。<br>这里需要注意：volatile 是针对 JIT 带来的优化，因此 JDK1.2 以前的版本基本不用考虑，另外，在 JDK1.3.1 开始，开始运用 HotSpot 虚拟机，用来代替 JIT。因此，是不是 HotSpot 的问题呢？这里需要再补充一点：<br>JIT 或 HotSpot 编译器在 server 模式和 client 模式编译不同，server 模式为了使线程运行更快，如果其中一个线程更改了变量 boolean flag 的值，那么另外一个线程会看不到，因为另外一个线程为了使得运行更快所以从寄存器或者本地 cache 中取值，而不是从内存中取值，那么使用 volatile 后，就告诉不论是什么线程，被volatile修饰的变量都要从内存中取值。<br>对于非 volatile 修饰的变量，尽管 jvm 的优化，会导致变量的可见性问题，但这种可见性的问题也只是在短时间内高并发的情况下发生，CPU 执行时会很快刷新 Cache，一般的情况下很难出现，而且出现这种问题是不可预测的，与 jvm, 机器配置环境等都有关。</p>
</blockquote>
<h2 id="Volatile-关键字（下）"><a href="#Volatile-关键字（下）" class="headerlink" title="Volatile 关键字（下）"></a>Volatile 关键字（下）</h2><p>在《Volatile 关键字（上）》一文中遗留了一个问题，就是 volatile 只修饰了 missedIt 变量，而没修饰value 变量，但是在线程读取 value 的值的时候，也读到的是最新的数据。</p>
<p>下面讲解问题出现的原因：</p>
<p>首先明确一点：假如有两个线程分别读写 volatile 变量时，线程 A 写入了某 volatile 变量，线程 B 在读取该 volatile 变量时，便能看到线程 A 对该 volatile 变量的写入操作，关键在这里，它不仅会看到对该 volatile 变量的写入操作，A 线程在写 volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，都将立即变得对 B 线程可见。<br>回过头来看文章中出现的问题，由于程序中 volatile 变量 missedIt 的写入操作在 value 变量写入操作之后，而且根据 volatile 规则，又不能重排序，因此，在线程 B 读取由线程 A 改变后的 missedIt 之后，它之前的 value 变量在线程 A 的改变也对线程 B 变得可见了。<br>我们颠倒一下 value=50 和 missedIt=true 这两行代码试下，即 missedIt=true 在前，value=50 在后，这样便会得到我们想要的结果：value 值的改变不会被看到。</p>
<p>这应该是 JDK1.2 之后对 volatile 规则做了一些修订的结果。</p>
<p>修改后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//value变量没有被标记为volatile  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;    </span><br><span class="line">    <span class="comment">//missedIt变量被标记为volatile  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> missedIt;  </span><br><span class="line">    <span class="comment">//creationTime不需要声明为volatile，因为代码执行中它没有发生变化  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> creationTime;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Volatile</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        value = <span class="number">10</span>;  </span><br><span class="line">        missedIt = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="comment">//获取当前时间，亦即调用Volatile构造函数时的时间  </span></span><br><span class="line">        creationTime = System.currentTimeMillis();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        print(<span class="string">&quot;entering run()&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//循环检查value的值是否不同  </span></span><br><span class="line">        <span class="keyword">while</span> ( value &lt; <span class="number">20</span> ) &#123;  </span><br><span class="line">            <span class="comment">//如果missedIt的值被修改为true，则通过break退出循环  </span></span><br><span class="line">            <span class="keyword">if</span>  ( missedIt ) &#123;  </span><br><span class="line">                <span class="comment">//进入同步代码块前，将value的值赋给currValue  </span></span><br><span class="line">                <span class="keyword">int</span> currValue = value;  </span><br><span class="line">                <span class="comment">//在一个任意对象上执行同步语句，目的是为了让该线程在进入和离开同步代码块时，  </span></span><br><span class="line">                <span class="comment">//将该线程中的所有变量的私有拷贝与共享内存中的原始值进行比较，  </span></span><br><span class="line">                <span class="comment">//从而发现没有用volatile标记的变量所发生的变化  </span></span><br><span class="line">                Object lock = <span class="keyword">new</span> Object();  </span><br><span class="line">                <span class="keyword">synchronized</span> ( lock ) &#123;  </span><br><span class="line">                    <span class="comment">//不做任何事  </span></span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//离开同步代码块后，将此时value的值赋给valueAfterSync  </span></span><br><span class="line">                <span class="keyword">int</span> valueAfterSync = value;  </span><br><span class="line">                print(<span class="string">&quot;in run() - see value=&quot;</span> + currValue +<span class="string">&quot;, but rumor has it that it changed!&quot;</span>);  </span><br><span class="line">                print(<span class="string">&quot;in run() - valueAfterSync=&quot;</span> + valueAfterSync);  </span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        print(<span class="string">&quot;leaving run()&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        print(<span class="string">&quot;entering workMethod()&quot;</span>);  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - about to sleep for 2 seconds&quot;</span>);  </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        <span class="comment">//仅在此改变value的值  </span></span><br><span class="line">        missedIt = <span class="keyword">true</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//      value = 50;  </span></span><br><span class="line">        print(<span class="string">&quot;in workMethod() - just set value=&quot;</span> + value);  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - about to sleep for 5 seconds&quot;</span>);  </span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        <span class="comment">//仅在此改变missedIt的值  </span></span><br><span class="line"><span class="comment">//      missedIt = true;  </span></span><br><span class="line">        value = <span class="number">50</span>;  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - just set missedIt=&quot;</span> + missedIt);  </span><br><span class="line">        print(<span class="string">&quot;in workMethod() - about to sleep for 3 seconds&quot;</span>);  </span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);  </span><br><span class="line">        print(<span class="string">&quot;leaving workMethod()&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*该方法的功能是在要打印的msg信息前打印出程序执行到此所化去的时间，以及打印msg的代码所在的线程 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//使用java.text包的功能，可以简化这个方法，但是这里没有利用这一点  </span></span><br><span class="line">        <span class="keyword">long</span> interval = System.currentTimeMillis() - creationTime;  </span><br><span class="line">        String tmpStr = <span class="string">&quot;    &quot;</span> + ( interval / <span class="number">1000.0</span> ) + <span class="string">&quot;000&quot;</span>;       </span><br><span class="line">        <span class="keyword">int</span> pos = tmpStr.indexOf(<span class="string">&quot;.&quot;</span>);  </span><br><span class="line">        String secStr = tmpStr.substring(pos - <span class="number">2</span>, pos + <span class="number">4</span>);  </span><br><span class="line">        String nameStr = <span class="string">&quot;        &quot;</span> + Thread.currentThread().getName();  </span><br><span class="line">        nameStr = nameStr.substring(nameStr.length() - <span class="number">8</span>, nameStr.length());      </span><br><span class="line">        System.out.println(secStr + <span class="string">&quot; &quot;</span> + nameStr + <span class="string">&quot;: &quot;</span> + msg);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//通过该构造函数可以获取实时时钟的当前时间  </span></span><br><span class="line">            Volatile vol = <span class="keyword">new</span> Volatile();  </span><br><span class="line">    </span><br><span class="line">            <span class="comment">//稍停100ms，以让实时时钟稍稍超前获取时间，使print（）中创建的消息打印的时间值大于0  </span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);    </span><br><span class="line">    </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(vol);  </span><br><span class="line">            t.start();  </span><br><span class="line">    </span><br><span class="line">            <span class="comment">//休眠100ms，让刚刚启动的线程有时间运行  </span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);    </span><br><span class="line">            <span class="comment">//workMethod方法在main线程中运行  </span></span><br><span class="line">            vol.workMethod();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> ( InterruptedException x ) &#123;  </span><br><span class="line">            System.err.println(<span class="string">&quot;one of the sleeps was interrupted&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/333.png" style="zoom:150%;" />

<p>很明显，这其实并不符合使用 volatile 的第二个条件：该变量要没有包含在具有其他变量的不变式中。因此，在这里使用 volatile 是不安全的。</p>
<p>附上一篇讲述 volatile 关键字正确使用的很好的文章：<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html">http://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a></p>
<h2 id="深入-Java-内存模型（1）"><a href="#深入-Java-内存模型（1）" class="headerlink" title="深入 Java 内存模型（1）"></a>深入 Java 内存模型（1）</h2><h3 id="happen—before-规则介绍"><a href="#happen—before-规则介绍" class="headerlink" title="happen—before 规则介绍"></a>happen—before 规则介绍</h3><p>Java 语言中有一个“先行发生”（happen—before）的规则，它是 Java 内存模型中定义的两项操作之间的偏序关系，如果操作 A 先行发生于操作 B，其意思就是说，在发生操作 B 之前，操作A产生的影响都能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等，它与时间上的先后发生基本没有太大关系。这个原则特别重要，它是判断数据是否存在竞争、线程是否安全的主要依据。</p>
<p>下面是 Java 内存模型中的八条可保证 happen—before 的规则，它们无需任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随机地重排序。</p>
<h6 id="⦁-程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作-happen—before（时间上）后执行的操作。"><a href="#⦁-程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作-happen—before（时间上）后执行的操作。" class="headerlink" title="⦁    程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作 happen—before（时间上）后执行的操作。"></a>⦁    程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作 happen—before（时间上）后执行的操作。</h6><h6 id="⦁-管理锁定规则：一个-unlock-操作-happen—before-后面（时间上的先后顺序，下同）对同一个锁的-lock-操作。"><a href="#⦁-管理锁定规则：一个-unlock-操作-happen—before-后面（时间上的先后顺序，下同）对同一个锁的-lock-操作。" class="headerlink" title="⦁    管理锁定规则：一个 unlock 操作 happen—before 后面（时间上的先后顺序，下同）对同一个锁的 lock 操作。"></a>⦁    管理锁定规则：一个 unlock 操作 happen—before 后面（时间上的先后顺序，下同）对同一个锁的 lock 操作。</h6><h6 id="⦁-volatile变量规则：对一个-volatile-变量的写操作-happen—before-后面对该变量的读操作。"><a href="#⦁-volatile变量规则：对一个-volatile-变量的写操作-happen—before-后面对该变量的读操作。" class="headerlink" title="⦁    volatile变量规则：对一个 volatile 变量的写操作 happen—before 后面对该变量的读操作。"></a>⦁    volatile变量规则：对一个 volatile 变量的写操作 happen—before 后面对该变量的读操作。</h6><h6 id="⦁-线程启动规则：Thread-对象的-start-方法-happen—before-此线程的每一个动作。"><a href="#⦁-线程启动规则：Thread-对象的-start-方法-happen—before-此线程的每一个动作。" class="headerlink" title="⦁    线程启动规则：Thread 对象的 start()方法 happen—before 此线程的每一个动作。"></a>⦁    线程启动规则：Thread 对象的 start()方法 happen—before 此线程的每一个动作。</h6><h6 id="⦁-线程终止规则：线程的所有操作都-happen—before-对此线程的终止检测，可以通过-Thread-join-方法结束-Thread-isAlive-的返回值等手段检测到线程已经终止执行。"><a href="#⦁-线程终止规则：线程的所有操作都-happen—before-对此线程的终止检测，可以通过-Thread-join-方法结束-Thread-isAlive-的返回值等手段检测到线程已经终止执行。" class="headerlink" title="⦁    线程终止规则：线程的所有操作都 happen—before 对此线程的终止检测，可以通过 Thread.join()方法结束 Thread.isAlive()的返回值等手段检测到线程已经终止执行。"></a>⦁    线程终止规则：线程的所有操作都 happen—before 对此线程的终止检测，可以通过 Thread.join()方法结束 Thread.isAlive()的返回值等手段检测到线程已经终止执行。</h6><h6 id="⦁-线程中断规则：对线程-interrupt-方法的调用-happen—before-发生于被中断线程的代码检测到中断时事件的发生。"><a href="#⦁-线程中断规则：对线程-interrupt-方法的调用-happen—before-发生于被中断线程的代码检测到中断时事件的发生。" class="headerlink" title="⦁    线程中断规则：对线程 interrupt()方法的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。"></a>⦁    线程中断规则：对线程 interrupt()方法的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。</h6><h6 id="⦁-对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before-它的-finalize-方法的开始。"><a href="#⦁-对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before-它的-finalize-方法的开始。" class="headerlink" title="⦁    对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before 它的 finalize()方法的开始。"></a>⦁    对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before 它的 finalize()方法的开始。</h6><h6 id="⦁-传递性：如果操作-A-happen—before-操作-B，操作-B-happen—before-操作-C，那么可以得出-A-happen—before-操作-C。"><a href="#⦁-传递性：如果操作-A-happen—before-操作-B，操作-B-happen—before-操作-C，那么可以得出-A-happen—before-操作-C。" class="headerlink" title="⦁    传递性：如果操作 A happen—before 操作 B，操作 B happen—before 操作 C，那么可以得出 A happen—before 操作 C。"></a>⦁    传递性：如果操作 A happen—before 操作 B，操作 B happen—before 操作 C，那么可以得出 A happen—before 操作 C。</h6><h3 id="时间上先后顺序和-happen—before-原则"><a href="#时间上先后顺序和-happen—before-原则" class="headerlink" title="时间上先后顺序和 happen—before 原则"></a>时间上先后顺序和 happen—before 原则</h3><p>”时间上执行的先后顺序“与”happen—before“之间有何不同呢？<br>首先来看操作 A 在时间上先与操作 B 发生，是否意味着操作 A happen—before 操作 B？<br>一个常用来分析的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.value = value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设存在线程 A 和线程 B，线程 A 先（时间上的先）调用了 setValue(3)操作，然后（时间上的后）线程B调用了同一对象的 getValue()方法，那么线程B得到的返回值一定是3吗？</p>
<p>对照以上八条 happen—before 规则，发现没有一条规则适合于这里的 value 变量，从而我们可以判定线程 A 中的 setValue(3)操作与线程 B 中的 getValue()操作不存在 happen—before 关系。因此，尽管线程 A 的 setValue(3)在操作时间上先于操作 B 的 getvalue()，但无法保证线程 B 的 getValue()操作一定观察到了线程 A 的 setValue(3)操作所产生的结果，也即是 getValue()的返回值不一定为 3（有可能是之前 setValue 所设置的值）。这里的操作不是线程安全的。</p>
<p>因此，”一个操作时间上先发生于另一个操作“并不代表”一个操作 happen—before 另一个操作“。</p>
<p>解决方法：可以将 setValue（int）方法和 getValue()方法均定义为 synchronized 方法，也可以把 value 定义为 volatile 变量（value 的修改并不依赖 value 的原值，符合 volatile 的使用场景），分别对应 happen—before 规则的第 2 和第 3 条。注意，只将 setValue（int）方法和 getvalue()方法中的一个定义为 synchronized 方法是不行的，必须对同一个变量的所有读写同步，才能保证不读取到陈旧的数据，仅仅同步读或写是不够的 。</p>
<p>其次来看，操作 A happen—before 操作 B，是否意味着操作 A 在时间上先与操作 B 发生？<br>看有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 1；  </span><br><span class="line">y &#x3D; 2; </span><br></pre></td></tr></table></figure>

<p>假设同一个线程执行上面两个操作：操作 A：x=1 和操作 B：y=2。根据 happen—before 规则的第 1 条，操作 A happen—before 操作 B，但是由于编译器的指令重排序（Java 语言规范规定了 JVM 线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致。这个过程通过叫做指令的重排序。指令重排序存在的意义在于：JVM 能够根据处理器的特性（CPU 的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合 CPU 的执行特点，最大限度的发挥机器的性能。在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整）等原因，操作 A 在时间上有可能后于操作 B 被处理器执行，但这并不影响 happen—before 原则的正确性。<br>因此，”一个操作 happen—before 另一个操作“并不代表”一个操作时间上先发生于另一个操作“。</p>
<p>最后，一个操作和另一个操作必定存在某个顺序，要么一个操作或者是先于或者是后于另一个操作，或者与两个操作同时发生。同时发生是完全可能存在的，特别是在多 CPU 的情况下。而两个操作之间却可能没有 happen-before 关系，也就是说有可能发生这样的情况，操作 A 不 happen-before 操作 B，操作 B 也不 happen-before 操作 A，用数学上的术语 happen-before 关系是个偏序关系。两个存在 happen-before 关系的操作不可能同时发生，一个操作 A happen-before 操作 B，它们必定在时间上是完全错开的，这实际上也是同步的语义之一（独占访问）。</p>
<h3 id="利用-happen—before-规则分析-DCL"><a href="#利用-happen—before-规则分析-DCL" class="headerlink" title="利用 happen—before 规则分析 DCL"></a>利用 happen—before 规则分析 DCL</h3><p>DCL 即双重检查加锁，下面是一个典型的在单例模式中使用 DCL 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> someField;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.someField = <span class="keyword">new</span> Random().nextInt(<span class="number">200</span>)+<span class="number">1</span>;<span class="comment">//(1)  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                     <span class="comment">// (2)  </span></span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class) &#123;     <span class="comment">// (3)  </span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;             <span class="comment">// (4)  </span></span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton(); <span class="comment">// (5)  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;                             <span class="comment">// (6)  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSomeField</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.someField;                       <span class="comment">// (7)  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>这里得到单一的 instance 实例是没有问题的，问题的关键在于尽管得到了 Singleton 的正确引用，但是却有可能访问到其成员变量的不正确值。具体来说 Singleton.getInstance().getSomeField() 有可能返回 someField 的默认值 0。如果程序行为正确的话，这应当是不可能发生的事，因为在构造函数里设置的 someField 的值不可能为 0。为也说明这种情况理论上有可能发生，我们只需要说明语句(1)和语句(7)并不存在 happen-before 关系。</p>
<p>假设线程Ⅰ是初次调用 getInstance()方法，紧接着线程Ⅱ也调用了 getInstance()方法和 getSomeField()方法，我们要说明的是线程Ⅰ的语句(1)并不 happen-before 线程Ⅱ的语句(7)。线程Ⅱ在执行 getInstance()方法的语句(2)时，由于对 instance 的访问并没有处于同步块中，因此线程Ⅱ可能观察到也可能观察不到线程Ⅰ在语句(5)时对 instance 的写入，也就是说 instance 的值可能为空也可能为非空。我们先假设 instance 的值非空，也就观察到了线程Ⅰ对 instance 的写入，这时线程Ⅱ就会执行语句(6)直接返回这个 instance 的值，然后对这个 instance 调用 getSomeField()方法，该方法也是在没有任何同步情况被调用，因此整个线程Ⅱ的操作都是在没有同步的情况下调用 ，这时我们便无法利用上述 8 条 happen-before 规则得到线程Ⅰ的操作和线程Ⅱ的操作之间的任何有效的 happen-before 关系（主要考虑规则的第 2 条，但由于线程Ⅱ没有在进入 synchronized 块，因此不存在 lock 与 unlock 锁的问题），这说明线程Ⅰ的语句(1)和线程Ⅱ的语句(7)之间并不存在 happen-before 关系，这就意味着线程Ⅱ在执行语句(7)完全有可能观测不到线程Ⅰ在语句(1)处对 someFiled 写入的值，这就是 DCL 的问题所在。很荒谬，是吧？DCL 原本是为了逃避同步，它达到了这个目的，也正是因为如此，它最终受到惩罚，这样的程序存在严重的 bug，虽然这种 bug 被发现的概率绝对比中彩票的概率还要低得多，而且是转瞬即逝，更可怕的是，即使发生了你也不会想到是 DCL 所引起的。</p>
<p>前面我们说了，线程Ⅱ在执行语句(2)时也有可能观察空值，如果是种情况，那么它需要进入同步块，并执行语句(4)。在语句(4)处线程Ⅱ还能够读到 instance 的空值吗？不可能。这里因为这时对 instance 的写和读都是发生在同一个锁确定的同步块中，这时读到的数据是最新的数据。为也加深印象，我再用 happen-before 规则分析一遍。线程Ⅱ在语句(3)处会执行一个 lock 操作，而线程Ⅰ在语句(5)后会执行一个 unlock 操作，这两个操作都是针对同一个锁–Singleton.class，因此根据第 2 条 happen-before 规则，线程Ⅰ的 unlock 操作 happen-before 线程Ⅱ的 lock 操作，再利用单线程规则，线程Ⅰ的语句(5) -&gt; 线程Ⅰ的 unlock 操作，线程Ⅱ的 lock 操作 -&gt; 线程Ⅱ的语句(4)，再根据传递规则，就有线程Ⅰ的语句(5) -&gt; 线程Ⅱ的语句(4)，也就是说线程Ⅱ在执行语句(4)时能够观测到线程Ⅰ在语句(5)时对 Singleton 的写入值。接着对返回的 instance 调用 getSomeField()方法时，我们也能得到线程Ⅰ的语句(1) -&gt; 线程Ⅱ的语句(7)（由于线程Ⅱ有进入 synchronized 块，根据规则 2 可得），这表明这时 getSomeField 能够得到正确的值。但是仅仅是这种情况的正确性并不妨碍 DCL 的不正确性，一个程序的正确性必须在所有的情况下的行为都是正确的，而不能有时正确，有时不正确。<br>对 DCL 的分析也告诉我们一条经验原则：对引用（包括对象引用和数组引用）的非同步访问，即使得到该引用的最新值，却并不能保证也能得到其成员变量（对数组而言就是每个数组元素）的最新值。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最简单而且安全的解决方法是使用 static 内部类的思想，它利用的思想是：一个类直到被使用时才被初始化，而类初始化的过程是非并行的，这些都有 JLS 保证。</p>
<blockquote>
<p>如下述代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lazy initialization holder class idiom for static fields  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> InstanceHolder.instance;   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>另外，可以将 instance 声明为 volatile，即  private volatile static LazySingleton instance;</p>
<p>这样我们便可以得到，线程Ⅰ的语句(5) -&gt; 语线程Ⅱ的句(2)，根据单线程规则，线程Ⅰ的语句(1) -&gt; 线程Ⅰ的语句(5)和语线程Ⅱ的句(2) -&gt; 语线程Ⅱ的句(7)，再根据传递规则就有线程Ⅰ的语句(1) -&gt; 语线程Ⅱ的句(7)，这表示线程Ⅱ能够观察到线程Ⅰ在语句(1)时对 someFiled 的写入值，程序能够得到正确的行为。</p>
<p>注： </p>
<p>1、volatile 屏蔽指令重排序的语义在 JDK1.5 中才被完全修复，此前的 JDK 中及时将变量声明为 volatile，也仍然不能完全避免重排序所导致的问题（主要是 volatile 变量前后的代码仍然存在重排序问题），这点也是在 JDK1.5 之前的 Java 中无法安全使用 DCL 来实现单例模式的原因。<br>2、把 volatile 写和 volatile 读这两个操作综合起来看，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前，所有可见的共享变量的值都将立即变得对读线程 B 可见。<br>3、 在 java5 之前对 final 字段的同步语义和其它变量没有什么区别，在 java5 中，final 变量一旦在构造函数中设置完成（前提是在构造函数中没有泄露 this 引用)，其它线程必定会看到在构造函数中设置的值。而 DCL 的问题正好在于看到对象的成员变量的默认值，因此我们可以将 LazySingleton的someField 变量设置成 final，这样在 java5 中就能够正确运行了。</p>
<h2 id="深入-Java-内存模型（2）"><a href="#深入-Java-内存模型（2）" class="headerlink" title="深入 Java 内存模型（2）"></a>深入 Java 内存模型（2）</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量主要是指共享变量，存在竞争问题的变量。Java 内存模型规定所有的变量都存储在主内存中，而每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（根据 Java 虚拟机规范的规定，volatile 变量依然有共享内存的拷贝，但是由于它特殊的操作顺序性规定——从工作内存中读写数据前，必须先将主内存中的数据同步到工作内存中，所有看起来如同直接在主内存中读写访问一般，因此这里的描述对于 volatile 也不例外）。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来完成。</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>Java 内存模型中定义了以下 8 种操作来完成主内存与工作内存之间交互的实现细节：<br>⦁    luck（锁定）：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。<br>⦁    unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。<br>⦁    read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的 load 动作使用。<br>⦁    load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。<br>⦁    use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得</p>
<p>字节码指令时将会执行这个操作。</p>
<p>⦁    assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的</p>
<p>字节码指令时执行这个操作。</p>
<p>⦁    store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中，以便随后的 write 操作使用。<br>⦁    write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量值放入主内存的变量中。</p>
<p>Java 内存模型还规定了执行上述 8 种基本操作时必须满足如下规则：</p>
<p>⦁    不允许 read 和 load、store 和 write 操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read 与 load 之间、store 与 write 之间是可插入其他指令的。<br>⦁    不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。<br>⦁    不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。<br>⦁    一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个</p>
<p>变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p>
<p>⦁    一个变量在同一个时刻只允许一条线程对其执行 lock 操作，但 lock 操作可以被同一个条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。<br>⦁    如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。<br>⦁    如果一个变量实现没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。<br>⦁    对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存（执行 store 和 write 操作）。</p>
<h3 id="Volatile-型变量的特殊规则"><a href="#Volatile-型变量的特殊规则" class="headerlink" title="Volatile 型变量的特殊规则"></a>Volatile 型变量的特殊规则</h3><p>Java 内存模型对 volatile 专门定义了一些特殊的访问规则，当一个变量被定义成 volatile 之后，他将具备两种特性：<br>⦁    保证此变量对所有线程的可见性。这里不具体解释了。需要注意，volatile 变量的写操作除了对它本身的读操作可见外，volatile 写操作之前的所有共享变量均对 volatile 读操作之后的操作可见，另外注意其适用场景。<br>⦁    禁止指令重排序优化。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得正确的结果，而不能保证变量赋值操作的顺序与程序中的执行顺序一致，在单线程中，我们是无法感知这一点的。</p>
<p>补充：Java 语言规范规定了 JVM 线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致，这个过程通过叫做指令的重排序。指令重排序存在的意义在于：JVM 能够根据处理器的特性（CPU 的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合 CPU 的执行特点，最大限度的发挥机器的性能。在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。</p>
<h3 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h3><p>final 类型的域是不能修改的，除了这一点外，在 Java 内存模型中，final 域还有着特殊的语义，final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。具体而言，就是被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看到 final 字段的值，而且其外、外部可见状态永远也不会改变。它所带来的安全性是最简单最纯粹的。</p>
<h3 id="long-和-double-型变量的特殊规则"><a href="#long-和-double-型变量的特殊规则" class="headerlink" title="long 和 double 型变量的特殊规则"></a>long 和 double 型变量的特殊规则</h3><p>Java 内存模型要求 lock、unlock、read、load、assign、use、store 和 write 这 8 个操作都具有原子性，但是对于 64 位的数据类型 long 和 double，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行。这样，如果有多个线程共享一个未被声明为 volatile 的 long 或 double 类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读到一个既非原值，也非其他线程修改值得代表了“半个变量”的数值。不过这种读取到“半个变量”的情况非常罕见，因为 Java 内存模型虽然允许虚拟机不把 long 和 double 变量的读写实现成原子操作，但允许迅疾选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。目前各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待，因此在编码时，不需要将 long 和 double 变量专门声明为 volatile。</p>
<h2 id="Executor-框架与线程池"><a href="#Executor-框架与线程池" class="headerlink" title="Executor 框架与线程池"></a>Executor 框架与线程池</h2><h3 id="Executor-框架简介"><a href="#Executor-框架简介" class="headerlink" title="Executor 框架简介"></a>Executor 框架简介</h3><p>在 Java 5 之后，并发编程引入了一堆新的启动、调度和管理线程的API。Executor 框架便是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。</p>
<p>Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等。<br>Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务，任务即一个实现了 Runnable 接口的类。ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如，ExecutorService 提供了关闭自己的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 可以调用 ExecutorService 的 shutdown（）方法来平滑地关闭 ExecutorService，调用该方法后，将导致 ExecutorService 停止接受任何新的任务且等待已经提交的任务执行完成(已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的)，当所有已经提交的任务执行完毕后将会关闭 ExecutorService。因此我们一般用该接口来实现和管理多线程。</p>
<p>ExecutorService 的生命周期包括三种状态：运行、关闭、终止。创建后便进入运行状态，当调用了 shutdown（）方法时，便进入关闭状态，此时意味着 ExecutorService 不再接受新的任务，但它还在执行已经提交了的任务，当素有已经提交了的任务执行完后，便到达终止状态。如果不调用 shutdown（）方法，ExecutorService 会一直处在运行状态，不断接收新的任务，执行新的任务，服务器端一般不需要关闭它，保持一直运行即可。</p>
<p>Executors 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了 ExecutorService 接口。<br>public static ExecutorService newFixedThreadPool(int nThreads)<br>创建固定数目线程的线程池。</p>
<p>public static ExecutorService newCachedThreadPool()<br>创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线 程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</p>
<p>public static ExecutorService newSingleThreadExecutor()<br>创建一个单线程化的Executor。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)<br>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</p>
<p>这四种方法都是用的 Executors 中的 ThreadFactory 建立的线程，下面就以上四个方法做个比较：</p>
<p>newCachedThreadPool()</p>
<p>将创建一个可缓存的线程池，如果线程池的规模超过处理需求，那么将回收空闲线程，当需求增加时，还可以添加新的线程，线程池规模不存在任何限制。</p>
<hr>
<p>⦁    缓存型池子，先查看池中有没有以前建立的线程，如果有，就 reuse 如果没有，就建一个新的线程加入池中<br>⦁    缓存型池子通常用于执行一些生存期很短的异步型任务 因此在一些面向连接的 daemon 型 SERVER 中用得不多。但对于生存期短的异步任务，它是 Executor 的首选。<br>⦁    能 reuse 的线程，必须是 timeout IDLE 内的池中线程，缺省 timeout 是 60s,超过这个 IDLE 时长，线程实例将被终止及移出池。<br>注意，放入 CachedThreadPool 的线程不必担心其结束，超过 TIMEOUT 不活动，其会自动被终止。</p>
<hr>
<p>newFixedThreadPool(int)</p>
<p>创建一个固定的长度的线程池，每当提交一个任务，就创建一个线程，直到达到线程池最大数量，此时线程池的规模将不会进行变化。（如果某个线程由于发生未预期的的Exception而结束，那么线程池会补充一个新的线程）</p>
<hr>
<p>⦁    newFixedThreadPool 与 cacheThreadPool 差不多，也是能 reuse 就用，但不能随时建新的线程。<br>⦁    其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。<br>⦁    和 cacheThreadPool 不同，FixedThreadPool 没有 IDLE 机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的 TCP 或 UDP IDLE 机制之类的），所以 FixedThreadPool 多数针对一些很稳定很固定的正规并发线程，多用于服务器。<br>⦁    从方法的源代码看，cache池和fixed 池调用的是同一个底层 池，只不过参数不同:<br>⦁    fixed 池线程数固定，并且是0秒IDLE（无IDLE）。<br>⦁    cache 池线程数支持 0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60 秒 IDLE 。</p>
<hr>
<p>newScheduledThreadPool(int)</p>
<hr>
<p>⦁    调度型线程池<br>⦁    这个池子里的线程可以按 schedule 依次 delay 执行，或周期执行</p>
<hr>
<p>SingleThreadExecutor()</p>
<p>将创建一个单线程的Executor,如果这个线程异常结束，那么会创建另一个线程来替代。此外，该线程池能保证任务在池中依照任务在队列中的顺序进行串行执行。（如队列FIFO,LIFO,优先级队列（PriorityQueue））</p>
<p>⦁    单例线程，任意时间池中只能有一个线程<br>⦁    用的是和 cache 池和 fixed 池相同的底层池，但线程数目是 1-1,0 秒 IDLE（无 IDLE）</p>
<hr>
<p>一般来说，CachedTheadPool 在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的 Executor 的首选，只有当这种方式会引发问题时（比如需要大量长时间面向连接的线程时），才需要考虑用 FixedThreadPool。（该段话摘自《Thinking in Java》第四版）</p>
<h3 id="Executor-执行-Runnable-任务"><a href="#Executor-执行-Runnable-任务" class="headerlink" title="Executor 执行 Runnable 任务"></a>Executor 执行 Runnable 任务</h3><p>通过 Executors 的以上四个静态工厂方法获得 ExecutorService 实例，而后调用该实例的 execute（Runnable command）方法即可。一旦 Runnable 任务传递到 execute（）方法，该方法便会自动在一个线程上执行。下面是 Executor 执行 Runnable 任务的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCachedThreadPool</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();   </span><br><span class="line"><span class="comment">//      ExecutorService executorService = Executors.newFixedThreadPool(5);  </span></span><br><span class="line"><span class="comment">//      ExecutorService executorService = Executors.newSingleThreadExecutor();  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;   </span><br><span class="line">            executorService.execute(<span class="keyword">new</span> TestRunnable());   </span><br><span class="line">            System.out.println(<span class="string">&quot;************* a&quot;</span> + i + <span class="string">&quot; *************&quot;</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">        executorService.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程被调用了。&quot;</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后的结果如下：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/44.png" style="zoom:150%;" />

<p>从结果中可以看出，pool-1-thread-1 和 pool-1-thread-2 均被调用了两次，这是随机的，execute 会首先在线程池中选择一个已有空闲线程来执行任务，如果线程池中没有空闲线程，它便会创建一个新的线程来执行任务。</p>
<h3 id="Executor-执行-Callable-任务"><a href="#Executor-执行-Callable-任务" class="headerlink" title="Executor 执行 Callable 任务"></a>Executor 执行 Callable 任务</h3><p>在 Java 5 之后，任务分两类：一类是实现了 Runnable 接口的类，一类是实现了 Callable 接口的类。两者都可以被 ExecutorService 执行，但是 Runnable 任务没有返回值，而 Callable 任务有返回值。并且 Callable 的 call()方法只能通过 ExecutorService 的 submit(Callable task) 方法来执行，并且返回一个 Future，是表示任务等待完成的 Future。</p>
<p>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常而 Callable 又返回结果，而且当获取返回结果时可能会抛出异常。Callable 中的 call()方法类似 Runnable 的 run()方法，区别同样是有返回值，后者没有。</p>
<p>当将一个 Callable 的对象传递给 ExecutorService 的 submit 方法，则该 call 方法自动在一个线程上执行，并且会返回执行结果 Future 对象。同样，将 Runnable 的对象传递给 ExecutorService 的 submit 方法，则该 run 方法自动在一个线程上执行，并且会返回执行结果 Future 对象，但是在该 Future 对象上调用 get 方法，将返回 null。<br>下面给出一个 Executor 执行 Callable 任务的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;   </span><br><span class="line"><span class="keyword">import</span> java.util.List;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();   </span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();   </span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建10个任务并执行   </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;   </span><br><span class="line">            <span class="comment">//使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中   </span></span><br><span class="line">            Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> TaskWithResult(i));   </span><br><span class="line">            <span class="comment">//将任务执行结果存储到List中   </span></span><br><span class="line">            resultList.add(future);   </span><br><span class="line">        &#125;   </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//遍历任务的结果   </span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs : resultList)&#123;   </span><br><span class="line">                <span class="keyword">try</span>&#123;   </span><br><span class="line">                    <span class="keyword">while</span>(!fs.isDone);<span class="comment">//Future返回如果没有完成，则一直循环等待，直到Future返回完成  </span></span><br><span class="line">                    System.out.println(fs.get());     <span class="comment">//打印各个线程（任务）执行的结果   </span></span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;   </span><br><span class="line">                    <span class="comment">//启动一次顺序关闭，执行以前提交的任务，但不接受新任务  </span></span><br><span class="line">                    executorService.shutdown();   </span><br><span class="line">                &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.id = id;   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 任务的具体过程，一旦任务传给ExecutorService的submit方法， </span></span><br><span class="line"><span class="comment">     * 则该方法自动在一个线程上执行 </span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;call()方法被自动调用！！！    &quot;</span> + Thread.currentThread().getName());   </span><br><span class="line">        <span class="comment">//该返回结果将被Future的get方法得到  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;call()方法被自动调用，任务返回的结果是：&quot;</span> + id + <span class="string">&quot;    &quot;</span> + Thread.currentThread().getName();   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>执行结果如下：</p>
<img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/1.png" style="zoom:150%;" />

<p>从结果中可以同样可以看出，submit 也是首先选择空闲线程来执行任务，如果没有，才会创建新的线程来执行任务。另外，需要注意：如果 Future 的返回尚未完成，则 get（）方法会阻塞等待，直到 Future 完成返回，可以通过调用 isDone（）方法判断 Future 是否完成了返回。</p>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>自定义线程池，可以用 ThreadPoolExecutor 类创建，它有多个构造方法来创建线程池，用该类很容易实现自定义的线程池，这里先贴上示例程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        <span class="comment">//创建等待队列   </span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>);   </span><br><span class="line">        <span class="comment">//创建线程池，池中保存的线程数为3，允许的最大线程数为5  </span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">50</span>,TimeUnit.MILLISECONDS,bqueue);   </span><br><span class="line">        <span class="comment">//创建七个任务   </span></span><br><span class="line">        Runnable t1 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t2 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t3 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t4 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t5 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t6 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t7 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        <span class="comment">//每个任务会在一个线程上执行  </span></span><br><span class="line">        pool.execute(t1);   </span><br><span class="line">        pool.execute(t2);   </span><br><span class="line">        pool.execute(t3);   </span><br><span class="line">        pool.execute(t4);   </span><br><span class="line">        pool.execute(t5);   </span><br><span class="line">        pool.execute(t6);   </span><br><span class="line">        pool.execute(t7);   </span><br><span class="line">        <span class="comment">//关闭线程池   </span></span><br><span class="line">        pool.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在执行。。。&quot;</span>);   </span><br><span class="line">        <span class="keyword">try</span>&#123;   </span><br><span class="line">            Thread.sleep(<span class="number">100</span>);   </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果如下：</p>
<p>从结果中可以看出，七个任务是在线程池的三个线程上执行的。这里简要说明下用到的 ThreadPoolExecuror 类的构造方法中各个参数的含义。</p>
<p>public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long   keepAliveTime, TimeUnit unit,BlockingQueue<Runnable> workQueue)<br>⦁    corePoolSize：线程池中所保存的核心线程数，包括空闲线程。<br>⦁    maximumPoolSize：池中允许的最大线程数。<br>⦁    keepAliveTime：线程池中的空闲线程所能持续的最长时间。<br>⦁    unit：持续时间的单位。<br>⦁    workQueue：任务执行前保存任务的队列，仅保存由 execute 方法提交的 Runnable 任务。</p>
<p>根据 ThreadPoolExecutor 源码前面大段的注释，我们可以看出，当试图通过 excute 方法讲一个 Runnable 任务添加到线程池中时，按照如下顺序来处理：<br>⦁    如果线程池中的线程数量少于 corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务；<br>⦁    如果线程池中的线程数量大于等于 corePoolSize，但缓冲队列 workQueue 未满，则将新添加的任务放到 workQueue 中，按照 FIFO 的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）；<br>⦁    如果线程池中的线程数量大于等于 corePoolSize，且缓冲队列 workQueue 已满，但线程池中的线程数量小于 maximumPoolSize，则会创建新的线程来处理被添加的任务；<br>⦁    如果线程池中的线程数量等于了 maximumPoolSize，有 4 种才处理方式（该构造方法调用了含有 5 个参数的构造方法，并将最后一个构造方法为 RejectedExecutionHandler 类型，它在处理线程溢出时有 4 种方式，这里不再细说，要了解的，自己可以阅读下源码）。</p>
<p>总结起来，也即是说，当有新的任务要处理时，先看线程池中的线程数量是否大于 corePoolSize，再看缓冲队列 workQueue 是否满，最后看线程池中的线程数量是否大于 maximumPoolSize。<br>另外，当线程池中的线程数量大于 corePoolSize 时，如果里面有线程的空闲时间超过了 keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量。</p>
<p>我们大致来看下 Executors 的源码，newCachedThreadPool 的不带 RejectedExecutionHandler 参数（即第五个参数，线程数量超过 maximumPoolSize 时，指定处理方式）的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  </span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,  </span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将 corePoolSize 设定为 0，而将 maximumPoolSize 设定为了 Integer 的最大值，线程空闲超过 60 秒，将会从线程池中移除。由于核心线程数为 0，因此每次添加任务，都会先从线程池中找空闲线程，如果没有就会创建一个线程（SynchronousQueue决定的，后面会说）来执行新的任务，并将该线程加入到线程池中，而最大允许的线程数为 Integer 的最大值，因此这个线程池理论上可以不断扩大。<br>再来看 newFixedThreadPool 的不带 RejectedExecutionHandler 参数的构造方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,  </span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,  </span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将 corePoolSize 和 maximumPoolSize 都设定为了 nThreads，这样便实现了线程池的大小的固定，不会动态地扩大，另外，keepAliveTime 设定为了 0，也就是说线程只要空闲下来，就会被移除线程池，敢于 LinkedBlockingQueue 下面会说。</p>
<h3 id="几种排队的策略"><a href="#几种排队的策略" class="headerlink" title="几种排队的策略"></a>几种排队的策略</h3><p>⦁    直接提交。缓冲队列采用 SynchronousQueue，它将任务直接交给线程处理而不保持它们。如果不存在可用于立即运行任务的线程（即线程池中的线程都在工作），则试图把任务加入缓冲队列将会失败，因此会构造一个新的线程来处理新添加的任务，并将其加入到线程池中。直接提交通常要求无界 maximumPoolSizes（Integer.MAX_VALUE） 以避免拒绝新提交的任务。newCachedThreadPool 采用的便是这种策略。<br>⦁    无界队列。使用无界队列（典型的便是采用预定义容量的 LinkedBlockingQueue，理论上是该缓冲队列可以对无限多的任务排队）将导致在所有 corePoolSize 线程都工作的情况下将新任务加入到缓冲队列中。这样，创建的线程就不会超过 corePoolSize，也因此，maximumPoolSize 的值也就无效了。当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。newFixedThreadPool采用的便是这种策略。<br>⦁    有界队列。当使用有限的 maximumPoolSizes 时，有界队列（一般缓冲队列使用 ArrayBlockingQueue，并制定队列的最大长度）有助于防止资源耗尽，但是可能较难调整和控制，队列大小和最大池大小需要相互折衷，需要设定合理的参数。</p>
<h2 id="Lock-锁与条件变量"><a href="#Lock-锁与条件变量" class="headerlink" title="Lock 锁与条件变量"></a>Lock 锁与条件变量</h2><h3 id="简单使用-Lock-锁"><a href="#简单使用-Lock-锁" class="headerlink" title="简单使用 Lock 锁"></a>简单使用 Lock 锁</h3><p>Java 5 中引入了新的锁机制——java.util.concurrent.locks 中的显式的互斥锁：Lock 接口，它提供了比synchronized 更加广泛的锁定操作。Lock 接口有 3 个实现它的类：ReentrantLock、ReetrantReadWriteLock.ReadLock 和 ReetrantReadWriteLock.WriteLock，即重入锁、读锁和写锁。lock 必须被显式地创建、锁定和释放，为了可以使用更多的功能，一般用 ReentrantLock 为其实例化。为了保证锁最终一定会被释放（可能会有异常发生），要把互斥区放在 try 语句块内，并在 finally 语句块中释放锁，尤其当有 return 语句时，return 语句必须放在 try 字句中，以确保 unlock()不会过早发生，从而将数据暴露给第二个任务。因此，采用 lock 加锁和释放锁的一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//默认使用非公平锁，如果要使用公平锁，需要传入参数true  </span></span><br><span class="line">........  </span><br><span class="line">lock.lock();  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">//更新对象的状态  </span></span><br><span class="line">    <span class="comment">//捕获异常，必要时恢复到原来的不变约束  </span></span><br><span class="line">   <span class="comment">//如果有return语句，放在这里  </span></span><br><span class="line"> <span class="keyword">finally</span> &#123;  </span><br><span class="line">       lock.unlock();        <span class="comment">//锁必须在finally块中释放  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ReetrankLock-与-synchronized-比较"><a href="#ReetrankLock-与-synchronized-比较" class="headerlink" title="ReetrankLock 与 synchronized 比较"></a>ReetrankLock 与 synchronized 比较</h3><h4 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h4><p>在 JDK1.5 中，synchronized 是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java 提供的 Lock 对象，性能更高一些。Brian Goetz 对这两种锁在 JDK1.5、单核处理器及双 Xeon 处理器环境下做了一组吞吐量对比的实验，发现多线程环境下，synchronized的吞吐量下降的非常严重，而ReentrankLock 则能基本保持在同一个比较稳定的水平上。但与其说 ReetrantLock 性能好，倒不如说 synchronized 还有非常大的优化余地，于是到了 JDK1.6，发生了变化，对 synchronize 加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在 JDK1.6 上 synchronize 的性能并不比 Lock 差。官方也表示，他们也更支持 synchronize，在未来的版本中还有优化余地，所以还是提倡在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行同步。<br>下面浅析以下两种锁机制的底层的实现策略。</p>
<p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因而这种同步又称为阻塞同步，它属于一种悲观的并发策略，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在 CPU 转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起 CPU 频繁的上下文切换导致效率很低。synchronized 采用的便是这种并发策略。<br>随着指令集的发展，我们有了另一种选择：基于冲突检测的乐观并发策略，通俗地讲就是先进性操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据被争用，产生了冲突，那就再进行其他的补偿措施（最常见的补偿措施就是不断地重试，直到试成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步被称为非阻塞同步。ReetrantLock 采用的便是这种并发策略。<br>在乐观的并发策略中，需要操作和冲突检测这两个步骤具备原子性，它靠硬件指令来保证，这里用的是 CAS 操作（Compare and Swap）。JDK1.5 之后，Java 程序才可以使用CAS操作。我们可以进一步研究 ReentrantLock 的源代码，会发现其中比较重要的获得锁的一个方法是 compareAndSetState，这里其实就是调用的 CPU 提供的特殊指令。现代的 CPU 提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起。</p>
<p>Java 5 中引入了注入 AutomicInteger、AutomicLong、AutomicReference 等特殊的原子性变量类，它们提供的如：compareAndSet()、incrementAndSet()和getAndIncrement()等方法都使用了 CAS 操作。因此，它们都是由硬件指令来保证的原子方法。</p>
<h4 id="用途比较"><a href="#用途比较" class="headerlink" title="用途比较"></a>用途比较</h4><p>基本语法上，ReentrantLock 与 synchronized 很相似，它们都具备一样的线程重入特性，只是代码写法上有点区别而已，一个表现为 API 层面的互斥锁（Lock），一个表现为原生语法层面的互斥锁（synchronized）。ReentrantLock 相对 synchronized 而言还是增加了一些高级功能，主要有以下三项：</p>
<hr>
<p>⦁    等待可中断：当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情，它对处理执行时间非常上的同步块很有帮助。而在等待由 synchronized 产生的互斥锁时，会一直阻塞，是不能被中断的。</p>
<hr>
<p>⦁    可实现公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序排队等待，而非公平锁则不保证这点，在锁释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁时非公平锁，ReentrantLock 默认情况下也是非公平锁，但可以通过构造方法 ReentrantLock（ture）来要求使用公平锁。</p>
<hr>
<p>⦁    锁可以绑定多个条件：ReentrantLock 对象可以同时绑定多个 Condition 对象（名曰：条件变量或条件队列），而在 synchronized 中，锁对象的 wait()和 notify()或 notifyAll()方法可以实现一个隐含条件，但如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无需这么做，只需要多次调用 newCondition()方法即可。而且我们还可以通过绑定 Condition 对象来判断当前线程通知的是哪些线程（即与 Condition 对象绑定在一起的其他线程）。</p>
<hr>
<h3 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h3><p>ReetrantLock 有两种锁：忽略中断锁和响应中断锁。忽略中断锁与 synchronized 实现的互斥锁一样，不能响应中断，而响应中断锁可以响应中断。</p>
<p>如果某一线程 A 正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程 B 不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，如果此时 ReetrantLock 提供的是忽略中断锁，则它不会去理会该中断，而是让线程B继续等待，而如果此时 ReetrantLock 提供的是响应中断锁，那么它便会处理中断，让线程 B 放弃等待，转而去处理其他事情。</p>
<p>获得响应中断锁的一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  </span><br><span class="line">...........  </span><br><span class="line">lock.lockInterruptibly();<span class="comment">//获取响应中断锁  </span></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">      <span class="comment">//更新对象的状态  </span></span><br><span class="line">      <span class="comment">//捕获异常，必要时恢复到原来的不变约束  </span></span><br><span class="line">      <span class="comment">//如果有return语句，放在这里  </span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">    lock.unlock();        <span class="comment">//锁必须在finally块中释放  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这里有一个不错的分析中断的示例代码（摘自网上）。</p>
<p>当用 synchronized 中断对互斥锁的等待时，并不起作用，该线程依然会一直等待，如下面的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">private</span> Object lock;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Buffer</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    lock = <span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;开始往这个buff写入数据…&quot;</span>);  </span><br><span class="line">        <span class="keyword">for</span> (;;)<span class="comment">// 模拟要处理很长时间      </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis()  </span><br><span class="line">                    - startTime &gt; Integer.MAX_VALUE) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;终于写完了&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;从这个buff读数据&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    Buffer buff = <span class="keyword">new</span> Buffer();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Writer writer = <span class="keyword">new</span> Writer(buff);  </span><br><span class="line">    <span class="keyword">final</span> Reader reader = <span class="keyword">new</span> Reader(buff);  </span><br><span class="line"></span><br><span class="line">    writer.start();  </span><br><span class="line">    reader.start();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();  </span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                <span class="comment">//等5秒钟去中断读      </span></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis()  </span><br><span class="line">                        - start &gt; <span class="number">5000</span>) &#123;  </span><br><span class="line">                    System.out.println(<span class="string">&quot;不等了，尝试中断&quot;</span>);  </span><br><span class="line">                    reader.interrupt();  <span class="comment">//尝试中断读线程  </span></span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();  </span><br><span class="line"><span class="comment">// 我们期待“读”这个线程能退出等待锁，可是事与愿违，一旦读这个线程发现自</span></span><br><span class="line"><span class="comment">// 己得不到锁， 就一直开始等待了，就算它等死，也得不到锁，</span></span><br><span class="line"><span class="comment">// 因为写线程要21亿秒才能完成 T_T ，即使我们中断它，  </span></span><br><span class="line"><span class="comment">// 它都不来响应下，看来真的要等死了。这个时候，ReentrantLock</span></span><br><span class="line"><span class="comment">// 给了一种机制让我们来响应中断，  </span></span><br><span class="line"><span class="comment">// 让“读”能伸能屈，勇敢放弃对这个锁的等待。</span></span><br><span class="line"><span class="comment">// 我们来改写Buffer这个类，就叫BufferInterruptibly吧，可中断缓存。  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Buffer buff;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(Buffer buff)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.buff = buff;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        buff.write();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Buffer buff;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reader</span><span class="params">(Buffer buff)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.buff = buff;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">        buff.read();<span class="comment">//这里估计会一直阻塞      </span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;读结束&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>执行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/1111118.png"></p>
<p>我们等待了很久，后面依然没有输出，说明读线程对互斥锁的等待并没有被中断，也就是该互斥锁没有响应对读线程的中断。<br>我们再将上面代码中 synchronized 的互斥锁改为 ReentrantLock 的响应中断锁，即改为如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferInterruptibly</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        lock.lock();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();  </span><br><span class="line">            System.out.println(<span class="string">&quot;开始往这个buff写入数据…&quot;</span>);  </span><br><span class="line">            <span class="keyword">for</span> (;;)<span class="comment">// 模拟要处理很长时间      </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis()  </span><br><span class="line">                        - startTime &gt; Integer.MAX_VALUE) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;终于写完了&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        lock.lockInterruptibly();<span class="comment">// 注意这里，可以响应中断      </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;从这个buff读数据&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        BufferInterruptibly buff = <span class="keyword">new</span> BufferInterruptibly();  </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> Writer2 writer = <span class="keyword">new</span> Writer2(buff);  </span><br><span class="line">        <span class="keyword">final</span> Reader2 reader = <span class="keyword">new</span> Reader2(buff);  </span><br><span class="line">    </span><br><span class="line">        writer.start();  </span><br><span class="line">        reader.start();  </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (System.currentTimeMillis()  </span><br><span class="line">                            - start &gt; <span class="number">5000</span>) &#123;  </span><br><span class="line">                        System.out.println(<span class="string">&quot;不等了，尝试中断&quot;</span>);  </span><br><span class="line">                        reader.interrupt();  <span class="comment">//此处中断读操作  </span></span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).start();  </span><br><span class="line">    </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BufferInterruptibly buff;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reader2</span><span class="params">(BufferInterruptibly buff)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.buff = buff;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            buff.read();<span class="comment">//可以收到中断的异常，从而有效退出      </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;我不读了&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;读结束&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BufferInterruptibly buff;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Writer2</span><span class="params">(BufferInterruptibly buff)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.buff = buff;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        buff.write();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/2222222.png"></p>
<p>从结果中可以看出，尝试中断后输出了 catch 语句块中的内容，也输出了后面的“读结束”，说明线程对互斥锁的等待被中断了，也就是该互斥锁响应了对读线程的中断。</p>
<h3 id="条件变量实现线程间协作"><a href="#条件变量实现线程间协作" class="headerlink" title="条件变量实现线程间协作"></a>条件变量实现线程间协作</h3><p>在生产者——消费者模型一文中，我们用 synchronized 实现互斥，并配合使用 Object 对象的 wait（）和 notify()或 notifyAll()方法来实现线程间协作。Java 5 之后，我们可以用 Reentrantlock 锁配合 Condition 对象上的 await()和 signal()或 signalAll()方法来实现线程间协作。在 ReentrantLock 对象上 newCondition()可以得到一个 Condition 对象，可以通过在 Condition 上调用 await()方法来挂起一个任务（线程），通过在 Condition 上调用 signal()来通知任务，从而唤醒一个任务，或者调用 signalAll()来唤醒所有在这个 Condition 上被其自身挂起的任务。另外，如果使用了公平锁，signalAll()的与 Condition 关联的所有任务将以 FIFO 队列的形式获取锁，如果没有使用公平锁，则获取锁的任务是随机的，这样我们便可以更好地控制处在 await 状态的任务获取锁的顺序。与 notifyAll()相比，signalAll()是更安全的方式。另外，它可以指定唤醒与自身 Condition 对象绑定在一起的任务。<br>下面将生产者——消费者模型一文中的代码改为用条件变量实现，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>&#123; <span class="comment">// 定义信息类  </span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;name&quot;</span>;<span class="comment">//定义name属性，为了与下面set的name属性区别开  </span></span><br><span class="line">    <span class="keyword">private</span> String content = <span class="string">&quot;content&quot;</span> ;<span class="comment">// 定义content属性，为了与下面set的content属性区别开  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;   <span class="comment">// 设置标志位,初始时先生产  </span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    </span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition(); <span class="comment">//产生一个Condition对象  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name,String content)</span></span>&#123;  </span><br><span class="line">        lock.lock();  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            <span class="keyword">while</span>(!flag)&#123;  </span><br><span class="line">                condition.await() ;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">this</span>.setName(name) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">            Thread.sleep(<span class="number">300</span>) ;  </span><br><span class="line">            <span class="keyword">this</span>.setContent(content) ;  <span class="comment">// 设置内容  </span></span><br><span class="line">            flag  = <span class="keyword">false</span> ; <span class="comment">// 改变标志位，表示可以取走  </span></span><br><span class="line">            condition.signal();  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        lock.lock();  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            <span class="keyword">while</span>(flag)&#123;  </span><br><span class="line">                condition.await() ;  </span><br><span class="line">            &#125;     </span><br><span class="line">            Thread.sleep(<span class="number">300</span>) ;  </span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() +   </span><br><span class="line">                <span class="string">&quot; --&gt; &quot;</span> + <span class="keyword">this</span>.getContent()) ;  </span><br><span class="line">            flag  = <span class="keyword">true</span> ;  <span class="comment">// 改变标志位，表示可以生产  </span></span><br><span class="line">            condition.signal();  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.content = content ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content ;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="comment">// 通过Runnable实现多线程  </span></span><br><span class="line">    <span class="keyword">private</span> Info info = <span class="keyword">null</span> ;      <span class="comment">// 保存Info引用  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Info info)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.info = info ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;   <span class="comment">// 定义标记位  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;  </span><br><span class="line">                <span class="keyword">this</span>.info.set(<span class="string">&quot;姓名--1&quot;</span>,<span class="string">&quot;内容--1&quot;</span>) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">                flag = <span class="keyword">false</span> ;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">this</span>.info.set(<span class="string">&quot;姓名--2&quot;</span>,<span class="string">&quot;内容--2&quot;</span>) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">                flag = <span class="keyword">true</span> ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Info info = <span class="keyword">null</span> ;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Info info)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.info = info ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">            <span class="keyword">this</span>.info.get() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCaseDemo</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Info info = <span class="keyword">new</span> Info(); <span class="comment">// 实例化Info对象  </span></span><br><span class="line">        Producer pro = <span class="keyword">new</span> Producer(info) ; <span class="comment">// 生产者  </span></span><br><span class="line">        Consumer con = <span class="keyword">new</span> Consumer(info) ; <span class="comment">// 消费者  </span></span><br><span class="line">        <span class="keyword">new</span> Thread(pro).start() ;  </span><br><span class="line">        <span class="comment">//启动了生产者线程后，再启动消费者线程  </span></span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">500</span>) ;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(con).start() ;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>执行后，同样可以得到如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名--1 --&gt; 内容--1</span><br><span class="line">姓名--2 --&gt; 内容--2</span><br><span class="line">姓名--1 --&gt; 内容--1</span><br><span class="line">姓名--2 --&gt; 内容--2</span><br><span class="line">姓名--1 --&gt; 内容--1</span><br><span class="line">姓名--2 --&gt; 内容--2</span><br><span class="line">姓名--1 --&gt; 内容--1</span><br><span class="line">姓名--2 --&gt; 内容--2</span><br><span class="line">姓名--1 --&gt; 内容--1</span><br><span class="line">姓名--2 --&gt; 内容--2</span><br></pre></td></tr></table></figure>



<p>从以上并不能看出用条件变量的 await()、signal()、signalAll()方法比用 Object 对象的 wait()、notify()、notifyAll()方法实现线程间协作有多少优点，但它在处理更复杂的多线程问题时，会有明显的优势。所以，Lock 和 Condition 对象只有在更加困难的多线程问题中才是必须的。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>另外，synchronized 获取的互斥锁不仅互斥读写操作、写写操作，还互斥读读操作，而读读操作时不会带来数据竞争的，因此对对读读操作也互斥的话，会降低性能。Java 5 中提供了读写锁，它将读锁和写锁分离，使得读读操作不互斥，获取读锁和写锁的一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();      </span><br><span class="line">rwl.writeLock().lock()  <span class="comment">//获取写锁  </span></span><br><span class="line">rwl.readLock().lock()  <span class="comment">//获取读锁  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用读锁来锁定读操作，用写锁来锁定写操作，这样写操作和写操作之间会互斥，读操作和写操作之间会互斥，但读操作和读操作就不会互斥。<br>《Java 并发编程实践》一书给出了使用 ReentrantLock 的最佳时机：<br>当你需要以下高级特性时，才应该使用：可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用 synchronized。</p>
<h2 id="阻塞队列与阻塞栈"><a href="#阻塞队列与阻塞栈" class="headerlink" title="阻塞队列与阻塞栈"></a>阻塞队列与阻塞栈</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是 Java 5 并发新特性中的内容，阻塞队列的接口是 java.util.concurrent.BlockingQueue，它有多个实现类：ArrayBlockingQueue、DelayQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue 等，用法大同小异，具体可查看 JDK 文档，这里简单举例看下 ArrayBlockingQueue，它实现了一个有界队列，当队列满时，便会阻塞等待，直到有元素出队，后续的元素才可以被加入队列。<br>看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span></span>&#123;   </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">                BlockingQueue&lt;String&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">20</span>);   </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;   </span><br><span class="line">                        <span class="comment">//将指定元素添加到此队列中   </span></span><br><span class="line">                        bqueue.put(<span class="string">&quot;加入元素&quot;</span> + i);   </span><br><span class="line">                        System.out.println(<span class="string">&quot;向阻塞队列中添加了元素:&quot;</span> + i);   </span><br><span class="line">                &#125;   </span><br><span class="line">                System.out.println(<span class="string">&quot;程序到此运行结束，即将退出----&quot;</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/6.png"></p>
<p>从执行结果中可以看出，由于队列中元素的数量限制在了 20 个，因此添加 20 个元素后，其他元素便在队列外阻塞等待，程序并没有终止。<br>如果队列已满后，我们将队首元素移出，并可以继续向阻塞队列中添加元素，修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span></span>&#123;   </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">                BlockingQueue&lt;String&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">20</span>);   </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;   </span><br><span class="line">                        <span class="comment">//将指定元素添加到此队列中   </span></span><br><span class="line">                        bqueue.put(<span class="string">&quot;&quot;</span> + i);   </span><br><span class="line">                        System.out.println(<span class="string">&quot;向阻塞队列中添加了元素:&quot;</span> + i);   </span><br><span class="line">                        <span class="keyword">if</span>(i &gt; <span class="number">18</span>)&#123;  </span><br><span class="line">                            <span class="comment">//从队列中获取队头元素，并将其移出队列  </span></span><br><span class="line">                            System.out.println(<span class="string">&quot;从阻塞队列中移除元素：&quot;</span> + bqueue.take());  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;   </span><br><span class="line">                System.out.println(<span class="string">&quot;程序到此运行结束，即将退出----&quot;</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>执行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/1111111.png"></p>
<p>从结果中可以看出，当添加了第 20 个元素后，我们从队首移出一个元素，这样便可以继续向队列中添加元素，之后每添加一个元素，便从将队首元素移除，这样程序便可以执行结束。</p>
<h3 id="阻塞栈"><a href="#阻塞栈" class="headerlink" title="阻塞栈"></a>阻塞栈</h3><p>阻塞栈与阻塞队列相似，只是它是 Java 6 中加入的新特性，阻塞栈的接口java.util.concurrent.BlockingDeque 也有很多实现类，使用方法也比较相似，具体查看 JDK 文档。<br>下面同样给出一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingDeque;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingDequeTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">            BlockingDeque&lt;String&gt; bDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;(<span class="number">20</span>);   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;   </span><br><span class="line">                <span class="comment">//将指定元素添加到此阻塞栈中  </span></span><br><span class="line">                bDeque.putFirst(<span class="string">&quot;&quot;</span> + i);   </span><br><span class="line">                System.out.println(<span class="string">&quot;向阻塞栈中添加了元素:&quot;</span> + i);   </span><br><span class="line">            &#125;   </span><br><span class="line">            System.out.println(<span class="string">&quot;程序到此运行结束，即将退出----&quot;</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br><span class="line">执行结果如下：</span><br><span class="line"></span><br><span class="line">程序依然会阻塞等待，我们改为如下代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingDeque;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingDequeTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">            BlockingDeque&lt;String&gt; bDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;(<span class="number">20</span>);   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;   </span><br><span class="line">                <span class="comment">//将指定元素添加到此阻塞栈中  </span></span><br><span class="line">                bDeque.putFirst(<span class="string">&quot;&quot;</span> + i);   </span><br><span class="line">                System.out.println(<span class="string">&quot;向阻塞栈中添加了元素:&quot;</span> + i);   </span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">18</span>)&#123;  </span><br><span class="line">                    <span class="comment">//从阻塞栈中取出栈顶元素，并将其移出  </span></span><br><span class="line">                    System.out.println(<span class="string">&quot;从阻塞栈中移出了元素：&quot;</span> + bDeque.pollFirst());  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;   </span><br><span class="line">            System.out.println(<span class="string">&quot;程序到此运行结束，即将退出----&quot;</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/itcastzp/PicgoBreeding/master/img/112313213121.png"></p>
<p>从结果中可以看出，当添加了第 20 个元素后，我们从将栈顶元素移处，这样便可以继续向栈中添加元素，之后每添加一个元素，便将栈顶元素移出，这样程序便可以执行结束。</p>
<h2 id="障碍器-CyclicBarrier"><a href="#障碍器-CyclicBarrier" class="headerlink" title="障碍器 CyclicBarrier"></a>障碍器 CyclicBarrier</h2><p>CyclicBarrier（又叫障碍器）同样是 Java 5 中加入的新特性，使用时需要导入java.util.concurrent.CylicBarrier。它适用于这样一种情况：你希望创建一组任务，它们并发地执行工作，另外的一个任务在这一组任务并发执行结束前一直阻塞等待，直到该组任务全部执行结束，这个任务才得以执行。这非常像 CountDownLatch，只是 CountDownLatch 是只触发一次的事件，而 CyclicBarrier 可以多次重用。<br>下面给出一个简单的实例来说明其用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;   </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">                <span class="comment">//创建CyclicBarrier对象，  </span></span><br><span class="line">                <span class="comment">//并设置执行完一组5个线程的并发任务后，再执行MainTask任务  </span></span><br><span class="line">           CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> MainTask());   </span><br><span class="line">                <span class="keyword">new</span> SubTask(<span class="string">&quot;A&quot;</span>, cb).start();   </span><br><span class="line">                <span class="keyword">new</span> SubTask(<span class="string">&quot;B&quot;</span>, cb).start();   </span><br><span class="line">             <span class="keyword">new</span> SubTask(<span class="string">&quot;C&quot;</span>, cb).start();   </span><br><span class="line">                <span class="keyword">new</span> SubTask(<span class="string">&quot;D&quot;</span>, cb).start();   </span><br><span class="line">                <span class="keyword">new</span> SubTask(<span class="string">&quot;E&quot;</span>, cb).start();  </span><br><span class="line">        &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 最后执行的任务 </span></span><br><span class="line"><span class="comment">  */</span>   </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MainTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">                System.out.println(<span class="string">&quot;......终于要执行最后的任务了......&quot;</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 一组并发任务  </span></span><br><span class="line"><span class="comment">  */</span>   </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SubTask</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> String name;   </span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cb;   </span><br><span class="line"></span><br><span class="line">        SubTask(String name, CyclicBarrier cb) &#123;   </span><br><span class="line">                <span class="keyword">this</span>.name = name;   </span><br><span class="line">                <span class="keyword">this</span>.cb = cb;   </span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">                System.out.println(<span class="string">&quot;[并发任务&quot;</span> + name + <span class="string">&quot;]  开始执行&quot;</span>);   </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) ;    <span class="comment">//模拟耗时的任务   </span></span><br><span class="line">                System.out.println(<span class="string">&quot;[并发任务&quot;</span> + name + <span class="string">&quot;]  开始执行完毕，通知障碍器&quot;</span>);   </span><br><span class="line">                <span class="keyword">try</span> &#123;   </span><br><span class="line">                        <span class="comment">//每执行完一项任务就通知障碍器   </span></span><br><span class="line">                        cb.await();   </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">                        e.printStackTrace();   </span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;   </span><br><span class="line">                        e.printStackTrace();   </span><br><span class="line">                &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>


<p>某次执行的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[并发任务A]  开始执行</span><br><span class="line">[并发任务B]  开始执行</span><br><span class="line">[并发任务D]  开始执行</span><br><span class="line">[并发任务E]  开始执行</span><br><span class="line">[并发任务A]  开始执行完毕，通知障碍器</span><br><span class="line">[并发任务E]  开始执行完毕，通知障碍器</span><br><span class="line">[并发任务D]  开始执行完毕，通知障碍器</span><br><span class="line">[并发任务C]  开始执行</span><br><span class="line">[并发任务B]  开始执行完毕，通知障碍器</span><br><span class="line">[并发任务C]  开始执行完毕，通知障碍器</span><br><span class="line">......终于要执行最后的任务了......</span><br></pre></td></tr></table></figure>

<p>从结果可以看出：MainTask 任务在一组中的 5 个任务执行完后才开始执行。</p>
<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>在操作系统中，信号量是个很重要的概念，它在控制进程间的协作方面有着非常重要的作用，通过对信号量的不同操作，可以分别实现进程间的互斥与同步。当然它也可以用于多线程的控制，我们完全可以通过使用信号量来自定义实现类似 Java 中的 synchronized、wait、notify 机制。<br>Java 并发包中的信号量 Semaphore 实际上是一个功能完毕的计数信号量，从概念上讲，它维护了一个许可集合，对控制一定资源的消费与回收有着很重要的意义。Semaphore 可以控制某个资源被同时访问的任务数，它通过acquire()获取一个许可，release()释放一个许可。如果被同时访问的任务数已满，则其他 acquire 的任务进入等待状态，直到有一个任务被 release 掉，它才能得到许可。<br>下面给出一个采用 Semaphore 控制并发访问数量的示例程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//采用新特性来启动和管理线程——内部使用线程池  </span></span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();  </span><br><span class="line">    <span class="comment">//只允许5个线程同时访问  </span></span><br><span class="line">    <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);  </span><br><span class="line">    <span class="comment">//模拟10个客户端访问  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)&#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num = index;  </span><br><span class="line">        Runnable run = <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    <span class="comment">//获取许可  </span></span><br><span class="line">                    semp.acquire();  </span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> +   </span><br><span class="line">                        Thread.currentThread().getName() + <span class="string">&quot;获得许可：&quot;</span>  + num);  </span><br><span class="line">                    <span class="comment">//模拟耗时的任务  </span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) ;  </span><br><span class="line">                    <span class="comment">//释放许可  </span></span><br><span class="line">                    semp.release();  </span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> +   </span><br><span class="line">                        Thread.currentThread().getName() + <span class="string">&quot;释放许可：&quot;</span>  + num);  </span><br><span class="line">                    System.out.println(<span class="string">&quot;当前允许进入的任务个数：&quot;</span> +  </span><br><span class="line">                        semp.availablePermits());  </span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">          exec.execute(run);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//关闭线程池  </span></span><br><span class="line">    exec.shutdown();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>某次执行的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">线程pool-1-thread-1获得许可：0</span><br><span class="line">线程pool-1-thread-1释放许可：0</span><br><span class="line">当前允许进入的任务个数：5</span><br><span class="line">线程pool-1-thread-2获得许可：1</span><br><span class="line">线程pool-1-thread-6获得许可：5</span><br><span class="line">线程pool-1-thread-4获得许可：3</span><br><span class="line">线程pool-1-thread-8获得许可：7</span><br><span class="line">线程pool-1-thread-2释放许可：1</span><br><span class="line">当前允许进入的任务个数：2</span><br><span class="line">线程pool-1-thread-5获得许可：4</span><br><span class="line">线程pool-1-thread-8释放许可：7</span><br><span class="line">线程pool-1-thread-3获得许可：2</span><br><span class="line">线程pool-1-thread-4释放许可：3</span><br><span class="line">线程pool-1-thread-10获得许可：9</span><br><span class="line">线程pool-1-thread-6释放许可：5</span><br><span class="line">线程pool-1-thread-10释放许可：9</span><br><span class="line">当前允许进入的任务个数：2</span><br><span class="line">线程pool-1-thread-3释放许可：2</span><br><span class="line">当前允许进入的任务个数：1</span><br><span class="line">线程pool-1-thread-5释放许可：4</span><br><span class="line">当前允许进入的任务个数：3</span><br><span class="line">线程pool-1-thread-7获得许可：6</span><br><span class="line">线程pool-1-thread-9获得许可：8</span><br><span class="line">线程pool-1-thread-7释放许可：6</span><br><span class="line">当前允许进入的任务个数：5</span><br><span class="line">当前允许进入的任务个数：3</span><br><span class="line">当前允许进入的任务个数：3</span><br><span class="line">当前允许进入的任务个数：3</span><br><span class="line">线程pool-1-thread-9释放许可：8</span><br><span class="line">当前允许进入的任务个数：5</span><br></pre></td></tr></table></figure>

<p>可以看出，Semaphore 允许并发访问的任务数一直为 5，当然，这里还很容易看出一点，就是 Semaphore 仅仅是对资源的并发访问的任务数进行监控，而不会保证线程安全，因此，在访问的时候，要自己控制线程的安全访问。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/09/Cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZP">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/09/Cache/" class="post-title-link" itemprop="url">Cache</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-07-09 11:10:01 / 修改时间：11:43:32" itemprop="dateCreated datePublished" datetime="2020-07-09T11:10:01+08:00">2020-07-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="高性能java缓存库-Caffeine"><a href="#高性能java缓存库-Caffeine" class="headerlink" title="高性能java缓存库-Caffeine"></a>高性能java缓存库-Caffeine</h2><h4 id="Caffeine简介"><a href="#Caffeine简介" class="headerlink" title="Caffeine简介"></a>Caffeine简介</h4><p>Caffeine基于java8的高性能，接近最优的缓存库。Caffeine提供的内存缓存使用参考Google guava的API。Caffeine是基于Google guava和 ConcurrentLinkedHashMap的设计经验上改进的成果。</p>
<p>Caffeine可以通过建造者模式灵活的组合以下特性：</p>
<p>通过异步自动加载实体到缓存中<br>基于大小的回收策略<br>基于时间的回收策略<br>自动刷新<br>key自动封装虚引用<br>value自动封装弱引用或软引用<br>实体过期或被删除的通知<br>写入外部资源<br>统计累计访问缓存</p>
<h4 id="加载策略"><a href="#加载策略" class="headerlink" title="加载策略"></a>加载策略</h4><p>Caffeine提供了3种加载策略:手动加载，同步加载，异步加载</p>
<p>手动加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;Key, Graph&gt; cache &#x3D; Caffeine.newBuilder()</span><br><span class="line">    .expireAfterWrite(10, TimeUnit.MINUTES)</span><br><span class="line">    .maximumSize(10_000)</span><br><span class="line">    .build();</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 检索一个entry，如果没有则为null</span><br><span class="line">Graph graph &#x3D; cache.getIfPresent(key);</span><br><span class="line">&#x2F;&#x2F; 检索一个entry，如果entry为null，则通过key创建一个entry并加入缓存</span><br><span class="line">graph &#x3D; cache.get(key, k -&gt; createExpensiveGraph(key));</span><br><span class="line">&#x2F;&#x2F; 插入或更新一个实体</span><br><span class="line">cache.put(key, graph);</span><br><span class="line">&#x2F;&#x2F; 移除一个实体</span><br><span class="line">cache.invalidate(key);</span><br></pre></td></tr></table></figure>

<p>同步加载<br>构造Cache时候，build方法传入一个CacheLoader实现类。实现load方法，通过key加载value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Key, Graph&gt; cache &#x3D; Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(10_000)</span><br><span class="line">    .expireAfterWrite(10, TimeUnit.MINUTES)</span><br><span class="line">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class="line">&#x2F;&#x2F;如果缓存种没有对应的value，通过createExpensiveGraph方法加载</span><br><span class="line">Graph graph &#x3D; cache.get(key);</span><br><span class="line"></span><br><span class="line">Map&lt;Key, Graph&gt; graphs &#x3D; cache.getAll(keys);</span><br><span class="line">异步加载</span><br><span class="line">AsyncLoadingCache&lt;Key, Graph&gt; cache &#x3D; Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(10_000)</span><br><span class="line">    .expireAfterWrite(10, TimeUnit.MINUTES)</span><br><span class="line">    .buildAsync((key, executor) -&gt; createExpensiveGraphAsync(key, executor));</span><br><span class="line">CompletableFuture&lt;Graph&gt; graph &#x3D; cache.get(key);</span><br><span class="line">CompletableFuture&lt;Map&lt;Key, Graph&gt;&gt; graphs &#x3D; cache.getAll(keys);</span><br></pre></td></tr></table></figure>
<p>AsyncLoadingCache 是 LoadingCache 的变体， 可以异步计算实体在一个线程池(Executor)上并且返回 CompletableFuture.</p>
<h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><p>Caffeine提供了3种回收策略：基于大小回收，基于时间回收，基于引用回收</p>
<p>基于大小回收<br>// 基于实体数量淘汰实体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Key, Graph&gt; graphs &#x3D; Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(10_000)</span><br><span class="line">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过权重来计算，每个实体都有不同的权重，总权重到达最高时淘汰实体。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .maximumWeight(10_000)<br>    .weigher((Key key, Graph graph) -&gt; graph.vertices().size())<br>    .build(key -&gt; createExpensiveGraph(key));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">到达最大大小时淘汰最近最少使用的实体</span><br><span class="line"></span><br><span class="line">基于时间回收</span><br><span class="line">实体被访问之后，在实体被读或被写后的一段时间后过期</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .expireAfterAccess(5, TimeUnit.MINUTES)<br>    .build(key -&gt; createExpensiveGraph(key));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基于写之后，在实体被写入后的一段时间后过期</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .expireAfterWrite(10, TimeUnit.MINUTES)<br>    .build(key -&gt; createExpensiveGraph(key));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自定义策略Expiry，可以自定义在实体被读，被更新，被创建后的时间过期。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .expireAfter(new Expiry&lt;Key, Graph&gt;() {<br>      public long expireAfterCreate(Key key, Graph graph, long currentTime) {<br>        // Use wall clock time, rather than nanotime, if from an external resource<br>        long seconds = graph.creationDate().plusHours(5)<br>            .minus(System.currentTimeMillis(), MILLIS)<br>            .toEpochSecond();<br>        return TimeUnit.SECONDS.toNanos(seconds);<br>      }<br>      public long expireAfterUpdate(Key key, Graph graph,<br>          long currentTime, long currentDuration) {<br>        return currentDuration;<br>      }<br>      public long expireAfterRead(Key key, Graph graph,<br>          long currentTime, long currentDuration) {<br>        return currentDuration;<br>      }<br>    })<br>    .build(key -&gt; createExpensiveGraph(key));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">基于引用回收</span><br><span class="line">java种有四种引用：强引用，软引用，弱引用和虚引用，caffeine可以将值封装成弱引用或软引用。</span><br><span class="line">软引用：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。</span><br><span class="line">弱引用：弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .weakKeys()<br>    .weakValues()<br>    .build(key -&gt; createExpensiveGraph(key));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .softValues()<br>    .build(key -&gt; createExpensiveGraph(key));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 自动刷新</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .maximumSize(10_000)<br>    .refreshAfterWrite(1, TimeUnit.MINUTES)<br>    .build(key -&gt; createExpensiveGraph(key));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在写后的持续时间过后，调用createExpensiveGraph刷新</span><br><span class="line"></span><br><span class="line">#### 移除通知</span><br></pre></td></tr></table></figure>
<p>Cache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .removalListener((Key key, Graph graph, RemovalCause cause) -&gt;<br>        System.out.printf(“Key %s was removed (%s)%n”, key, cause))<br>    .build();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过removalListener添加实体移除监听器</span><br><span class="line"></span><br><span class="line">#### 写到外部存储</span><br><span class="line">通过CacheWriter 可以将缓存回写的外部存储中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>  .writer(new CacheWriter&lt;Key, Graph&gt;() {<br>    @Override public void write(Key key, Graph graph) {<br>      // 写入到外部存储或二级缓存<br>    }<br>    @Override public void delete(Key key, Graph graph, RemovalCause cause) {<br>      // 删除外部存储或者二级缓存<br>    }<br>  })<br>  .build(key -&gt; createExpensiveGraph(key));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用场景</span><br><span class="line"></span><br><span class="line">#### 缓存同步数据库</span><br><span class="line">多级缓存同步</span><br><span class="line">注意，CacheWriter不能与弱键或AsyncLoadingCache一起使用</span><br><span class="line"></span><br><span class="line">#### 统计缓存使用情况</span><br></pre></td></tr></table></figure>
<p>Cache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder()<br>    .maximumSize(10_000)<br>    .recordStats()<br>    .build();</p>
<pre><code>通过使用Caffeine.recordStats(), 可以转化成一个统计的集合. 通过 Cache.stats() 返回一个CacheStats。CacheStats提供以下统计方法

hitRate(): 返回缓存命中率
evictionCount(): 缓存回收数量
averageLoadPenalty(): 加载新值的平均时间</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZP</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
